File: ./src/lib/server/features/api/application/api-service.ts
Contents:
import type { HashRepository } from '../../common/domain/repositories/hash'
import type { ApiKeyRepository } from '../domain/repositories/api-key'
import { ValidateApiKeyCommand } from './commands/validate-api-key'

export class ApiService {
  private validateApiKeyCommand: ValidateApiKeyCommand

  constructor(apiKeyRepo: ApiKeyRepository, apiKeyHashRepo: HashRepository) {
    this.validateApiKeyCommand = new ValidateApiKeyCommand(apiKeyRepo, apiKeyHashRepo)
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    return this.validateApiKeyCommand.execute(apiKey)
  }
}

---

File: ./src/lib/server/features/api/application/commands/validate-api-key.ts
Contents:
import type { HashRepository } from '../../../common/domain/repositories/hash'
import type { ApiKeyRepository } from '../../domain/repositories/api-key'

export class ValidateApiKeyCommand {
  constructor(
    private apiKeyRepo: ApiKeyRepository,
    private apiKeyHashRepo: HashRepository,
  ) {}

  async execute(apiKey: string): Promise<boolean> {
    const keyHash = await this.apiKeyHashRepo.hash(apiKey)

    const maybeExistingKey = await this.apiKeyRepo.findByKeyHash(keyHash)
    return maybeExistingKey !== undefined
  }
}

---

File: ./src/lib/server/features/api/domain/entities/api-key.ts
Contents:
export class ApiKey {
  constructor(public keyHash: string) {}
}

---

File: ./src/lib/server/features/api/domain/repositories/api-key.ts
Contents:
import type { ApiKey } from '../entities/api-key'

export type ApiKeyRepository = {
  findByKeyHash(keyHash: string): Promise<ApiKey | undefined>
}

---

File: ./src/lib/server/features/api/infrastructure/repositories/api-key/drizzle-api-key.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'

import type { ApiKey } from '../../../domain/entities/api-key'
import type { ApiKeyRepository } from '../../../domain/repositories/api-key'

export class DrizzleApiKeyRepository implements ApiKeyRepository {
  constructor(private db: IDrizzleConnection) {}

  findByKeyHash(keyHash: string): Promise<ApiKey | undefined> {
    return this.db.query.apiKeys.findFirst({
      where: (apiKeys, { eq }) => eq(apiKeys.keyHash, keyHash),
    })
  }
}

---

File: ./src/lib/server/features/authentication/application/authentication-service.ts
Contents:
import type { HashRepository } from '../../common/domain/repositories/hash'
import type { CreatedAccount } from '../domain/entities/account'
import type { Cookie } from '../domain/entities/cookie'
import type { PasswordResetToken } from '../domain/entities/password-reset-token'
import type { CreatedSession } from '../domain/entities/session'
import type { AccountRepository } from '../domain/repositories/account'
import type { PasswordResetTokenRepository } from '../domain/repositories/password-reset-token'
import type { SessionRepository } from '../domain/repositories/session'
import type { TokenGenerator } from '../domain/repositories/token-generator'
import { LoginCommand } from './commands/login'
import { LogoutCommand } from './commands/logout'
import { RegisterCommand } from './commands/register'
import { RequestPasswordResetCommand } from './commands/request-password-reset'
import { ResetPasswordCommand } from './commands/reset-password'
import { ValidatePasswordResetTokenCommand } from './commands/validate-password-reset-token'
import { ValidateSessionCommand } from './commands/validate-session'
import type { AccountNotFoundError } from './errors/account-not-found'
import type { InvalidLoginError } from './errors/invalid-login'
import type { NonUniqueUsernameError } from './errors/non-unique-username'
import type { PasswordResetTokenExpiredError } from './errors/password-reset-token-expired'
import type { PasswordResetTokenNotFoundError } from './errors/password-reset-token-not-found'

export class AuthenticationService {
  private registerCommand: RegisterCommand
  private loginCommand: LoginCommand
  private logoutCommand: LogoutCommand
  private validateSessionCommand: ValidateSessionCommand
  private requestPasswordResetCommand: RequestPasswordResetCommand
  private validatePasswordResetTokenCommand: ValidatePasswordResetTokenCommand
  private resetPasswordCommand: ResetPasswordCommand

  constructor(
    accountRepo: AccountRepository,
    sessionRepo: SessionRepository,
    passwordResetTokenRepo: PasswordResetTokenRepository,
    passwordHashRepo: HashRepository,
    passwordResetTokenHashRepo: HashRepository,
    passwordResetTokenGeneratorRepo: TokenGenerator,
  ) {
    this.registerCommand = new RegisterCommand(accountRepo, sessionRepo, passwordHashRepo)
    this.loginCommand = new LoginCommand(accountRepo, sessionRepo, passwordHashRepo)
    this.logoutCommand = new LogoutCommand(sessionRepo)
    this.validateSessionCommand = new ValidateSessionCommand(accountRepo, sessionRepo)
    this.requestPasswordResetCommand = new RequestPasswordResetCommand(
      passwordResetTokenRepo,
      passwordResetTokenGeneratorRepo,
      passwordResetTokenHashRepo,
    )
    this.validatePasswordResetTokenCommand = new ValidatePasswordResetTokenCommand(
      passwordResetTokenRepo,
      passwordResetTokenHashRepo,
    )
    this.resetPasswordCommand = new ResetPasswordCommand(
      accountRepo,
      sessionRepo,
      passwordResetTokenRepo,
      passwordHashRepo,
    )
  }

  register(username: string, password: string): Promise<Cookie | NonUniqueUsernameError> {
    return this.registerCommand.execute(username, password)
  }

  login(username: string, password: string): Promise<Cookie | InvalidLoginError> {
    return this.loginCommand.execute(username, password)
  }

  logout(sessionId: string): Promise<Cookie> {
    return this.logoutCommand.execute(sessionId)
  }

  validateSession(sessionId: string | undefined): Promise<{
    account: CreatedAccount | undefined
    session: CreatedSession | undefined
    cookie: Cookie | undefined
  }> {
    return this.validateSessionCommand.execute(sessionId)
  }

  requestPasswordReset(accountId: number): Promise<string> {
    return this.requestPasswordResetCommand.execute(accountId)
  }

  checkPasswordResetToken(
    verificationToken: string,
  ): Promise<
    PasswordResetToken | PasswordResetTokenNotFoundError | PasswordResetTokenExpiredError
  > {
    return this.validatePasswordResetTokenCommand.execute(verificationToken)
  }

  resetPassword(
    passwordResetToken: PasswordResetToken,
    newPassword: string,
  ): Promise<Cookie | AccountNotFoundError> {
    return this.resetPasswordCommand.execute(passwordResetToken, newPassword)
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/login.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { NewAccount } from '../../domain/entities/account'
import { Cookie } from '../../domain/entities/cookie'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { createLucia } from '../../infrastructure/session/lucia'
import { LuciaSessionRepository } from '../../infrastructure/session/lucia-session-repository'
import { InvalidLoginError } from '../errors/invalid-login'
import { LoginCommand } from './login'

async function setupCommand(options: {
  dbConnection: IDrizzleConnection
  existingAccount?: { username: string; password: string }
}) {
  const accountRepo = new DrizzleAccountRepository(options.dbConnection)
  const sessionRepo = new LuciaSessionRepository(createLucia(options.dbConnection))
  const passwordHashRepo = new BcryptHashRepository()

  if (options.existingAccount) {
    await accountRepo.create(
      new NewAccount({
        username: options.existingAccount.username,
        passwordHash: await passwordHashRepo.hash(options.existingAccount.password),
      }),
    )
  }

  const login = new LoginCommand(accountRepo, sessionRepo, passwordHashRepo)

  async function getAccountSessions(username: string) {
    const account = await accountRepo.findByUsername(username)
    if (!account) return []

    const sessions = await sessionRepo.findByAccountId(account.id)
    return sessions
  }

  return { login, getAccountSessions }
}

describe('login', () => {
  test('should login an account successfully', async ({ dbConnection }) => {
    const { login } = await setupCommand({
      dbConnection,
      existingAccount: { username: 'testaccount', password: 'password123' },
    })

    const result = await login.execute('testaccount', 'password123')

    expect(result).toBeInstanceOf(Cookie)
  })

  test('should return InvalidLoginError for incorrect password', async ({ dbConnection }) => {
    const { login } = await setupCommand({
      dbConnection,
      existingAccount: { username: 'testaccount', password: 'password123' },
    })

    const result = await login.execute('testaccount', 'wrongpassword')

    expect(result).toBeInstanceOf(InvalidLoginError)
  })

  test('should return InvalidLoginError for non-existent account', async ({ dbConnection }) => {
    const { login } = await setupCommand({ dbConnection })

    const result = await login.execute('nonexistentaccount', 'password123')

    expect(result).toBeInstanceOf(InvalidLoginError)
  })

  test('should create a new session on successful login', async ({ dbConnection }) => {
    const { login, getAccountSessions } = await setupCommand({
      dbConnection,
      existingAccount: { username: 'testaccount', password: 'password123' },
    })

    await login.execute('testaccount', 'password123')

    const sessions = await getAccountSessions('testaccount')
    expect(sessions).toHaveLength(1)
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/login.ts
Contents:
import type { HashRepository } from '../../../common/domain/repositories/hash'
import type { Cookie } from '../../domain/entities/cookie'
import { NewSession } from '../../domain/entities/session'
import type { AccountRepository } from '../../domain/repositories/account'
import type { SessionRepository } from '../../domain/repositories/session'
import { InvalidLoginError } from '../errors/invalid-login'

export class LoginCommand {
  constructor(
    private accountRepo: AccountRepository,
    private sessionRepo: SessionRepository,
    private passwordHashRepo: HashRepository,
  ) {}

  async execute(username: string, password: string): Promise<Cookie | InvalidLoginError> {
    const account = await this.accountRepo.findByUsername(username)
    if (!account) {
      // spend some time to "waste" some time
      // this makes brute forcing harder
      await this.passwordHashRepo.hash(password)
      return new InvalidLoginError()
    }

    const validPassword = await this.passwordHashRepo.compare(password, account.passwordHash)
    if (!validPassword) {
      return new InvalidLoginError()
    }

    const session = await this.sessionRepo.create(new NewSession(account.id))

    const cookie = this.sessionRepo.createCookie(session.id)

    return cookie
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/logout.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { NewAccount } from '../../domain/entities/account'
import { Cookie } from '../../domain/entities/cookie'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { createLucia } from '../../infrastructure/session/lucia'
import { LuciaSessionRepository } from '../../infrastructure/session/lucia-session-repository'
import { LoginCommand } from './login'
import { LogoutCommand } from './logout'

function setupCommand(options: { dbConnection: IDrizzleConnection }) {
  const sessionRepo = new LuciaSessionRepository(createLucia(options.dbConnection))

  const logout = new LogoutCommand(sessionRepo)

  async function createLoggedInAccount(loggedInAccount: { username: string; password: string }) {
    const accountRepo = new DrizzleAccountRepository(options.dbConnection)
    const passwordHashRepo = new BcryptHashRepository()

    await accountRepo.create(
      new NewAccount({
        username: loggedInAccount.username,
        passwordHash: await passwordHashRepo.hash(loggedInAccount.password),
      }),
    )

    const login = new LoginCommand(accountRepo, sessionRepo, passwordHashRepo)
    const cookie = await login.execute(loggedInAccount.username, loggedInAccount.password)

    if (!(cookie instanceof Cookie)) {
      expect.fail('Login failed')
    }

    return { cookie }
  }

  async function getAccountSessions(username: string) {
    const accountRepo = new DrizzleAccountRepository(options.dbConnection)

    const account = await accountRepo.findByUsername(username)
    if (!account) return []

    const sessions = await sessionRepo.findByAccountId(account.id)
    return sessions
  }

  return { logout, createLoggedInAccount, getAccountSessions }
}

describe('logout', () => {
  test('should logout an account successfully', async ({ dbConnection }) => {
    const { logout, createLoggedInAccount } = setupCommand({ dbConnection })
    const { cookie } = await createLoggedInAccount({
      username: 'testaccount',
      password: 'password123',
    })

    const logoutResult = await logout.execute(cookie.value)

    expect(logoutResult).toBeInstanceOf(Cookie)
    expect(logoutResult.value).toBe('')
  })

  test('should delete the session on logout', async ({ dbConnection }) => {
    const { logout, createLoggedInAccount, getAccountSessions } = setupCommand({ dbConnection })
    const { cookie } = await createLoggedInAccount({
      username: 'sessionaccount',
      password: 'password123',
    })

    await logout.execute(cookie.value)

    const sessions = await getAccountSessions('sessionaccount')
    expect(sessions).toHaveLength(0)
  })

  test('should return an empty cookie when logging out with invalid session ID', async ({
    dbConnection,
  }) => {
    const { logout } = setupCommand({ dbConnection })

    const result = await logout.execute('invalid_session_id')

    expect(result).toBeInstanceOf(Cookie)
    expect(result.value).toBe('')
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/logout.ts
Contents:
import type { Cookie } from '../../domain/entities/cookie'
import type { SessionRepository } from '../../domain/repositories/session'

export class LogoutCommand {
  constructor(private sessionRepo: SessionRepository) {}

  async execute(sessionId: string): Promise<Cookie> {
    await this.sessionRepo.delete(sessionId)

    const cookie = this.sessionRepo.createCookie(undefined)

    return cookie
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/register.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { Cookie } from '../../domain/entities/cookie'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { createLucia } from '../../infrastructure/session/lucia'
import { LuciaSessionRepository } from '../../infrastructure/session/lucia-session-repository'
import { NonUniqueUsernameError } from '../errors/non-unique-username'
import { RegisterCommand } from './register'

function setupCommand(options: { dbConnection: IDrizzleConnection }) {
  const accountRepo = new DrizzleAccountRepository(options.dbConnection)
  const sessionRepo = new LuciaSessionRepository(createLucia(options.dbConnection))
  const passwordHashRepo = new BcryptHashRepository()

  const register = new RegisterCommand(accountRepo, sessionRepo, passwordHashRepo)

  async function getAccount(username: string) {
    const account = await accountRepo.findByUsername(username)
    return account
  }

  async function getAccountSessions(username: string) {
    const account = await accountRepo.findByUsername(username)
    if (!account) return []

    const sessions = await sessionRepo.findByAccountId(account.id)
    return sessions
  }

  return { register, getAccount, getAccountSessions }
}

describe('register', () => {
  test('should register a new account successfully', async ({ dbConnection }) => {
    const { register, getAccount } = setupCommand({ dbConnection })

    const result = await register.execute('newaccount', 'password123')

    expect(result).toBeInstanceOf(Cookie)

    const account = await getAccount('newaccount')
    expect(account).toBeDefined()
    expect(account?.username).toBe('newaccount')
  })

  test('should not register an account with an existing username', async ({ dbConnection }) => {
    const { register } = setupCommand({ dbConnection })

    // First, register an account
    await register.execute('existingaccount', 'password123')

    // Try to register again with the same username
    const result = await register.execute('existingaccount', 'anotherpassword')

    expect(result).toBeInstanceOf(NonUniqueUsernameError)
  })

  test('should hash the password before storing', async ({ dbConnection }) => {
    const { register, getAccount } = setupCommand({ dbConnection })

    await register.execute('hashtest', 'password123')

    const account = await getAccount('hashtest')
    expect(account).toBeDefined()
    expect(account?.passwordHash).toBeTypeOf('string')
    expect(account?.passwordHash).not.toBe('password123') // should be hashed
  })

  test('should create a session for the new account', async ({ dbConnection }) => {
    const { register, getAccountSessions } = setupCommand({ dbConnection })

    await register.execute('sessionaccount', 'password123')

    const sessions = await getAccountSessions('sessionaccount')
    expect(sessions).toHaveLength(1)
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/register.ts
Contents:
import type { HashRepository } from '../../../common/domain/repositories/hash'
import { NewAccount } from '../../domain/entities/account'
import type { Cookie } from '../../domain/entities/cookie'
import { NewSession } from '../../domain/entities/session'
import { NonUniqueUsernameError as DomainNonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { type AccountRepository } from '../../domain/repositories/account'
import type { SessionRepository } from '../../domain/repositories/session'
import { NonUniqueUsernameError } from '../errors/non-unique-username'

export class RegisterCommand {
  constructor(
    private accountRepo: AccountRepository,
    private sessionRepo: SessionRepository,
    private passwordHashRepo: HashRepository,
  ) {}

  async execute(username: string, password: string): Promise<Cookie | NonUniqueUsernameError> {
    const newAccount = new NewAccount({
      username,
      passwordHash: await this.passwordHashRepo.hash(password),
    })

    const maybeAccount = await this.accountRepo.create(newAccount)
    if (maybeAccount instanceof DomainNonUniqueUsernameError) {
      return new NonUniqueUsernameError(maybeAccount.username)
    }
    const account = maybeAccount

    const session = await this.sessionRepo.create(new NewSession(account.id))

    const cookie = this.sessionRepo.createCookie(session.id)

    return cookie
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/request-password-reset.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { Sha256HashRepository } from '../../../common/infrastructure/repositories/hash/sha256-hash-repository'
import { NewAccount } from '../../domain/entities/account'
import { PasswordResetToken } from '../../domain/entities/password-reset-token'
import { NonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { DrizzlePasswordResetTokenRepository } from '../../infrastructure/password-reset-token/drizzle-password-reset-token-repository'
import { CryptoTokenGenerator } from '../../infrastructure/token/crypto-token-generator'
import { RequestPasswordResetCommand } from './request-password-reset'

function setup(dbConnection: IDrizzleConnection) {
  const passwordResetTokenRepo = new DrizzlePasswordResetTokenRepository(dbConnection)
  const passwordResetTokenGeneratorRepo = new CryptoTokenGenerator()
  const passwordResetTokenHashRepo = new Sha256HashRepository()

  const requestPasswordReset = new RequestPasswordResetCommand(
    passwordResetTokenRepo,
    passwordResetTokenGeneratorRepo,
    passwordResetTokenHashRepo,
  )

  async function createAccount(data: { username: string; password: string }) {
    const accountRepo = new DrizzleAccountRepository(dbConnection)
    const passwordHashRepo = new BcryptHashRepository()

    const account = await accountRepo.create(
      new NewAccount({
        username: data.username,
        passwordHash: await passwordHashRepo.hash(data.password),
      }),
    )

    if (account instanceof NonUniqueUsernameError) {
      expect.fail('Account creation failed due to non-unique username')
    }

    return account
  }

  async function createPasswordResetToken(accountId: number) {
    const existingToken = new PasswordResetToken(accountId, 'existing_hash', new Date())
    await passwordResetTokenRepo.create(existingToken)
    return existingToken
  }

  async function getPasswordResetToken(tokenHash: string) {
    return passwordResetTokenRepo.findByTokenHash(tokenHash)
  }

  return {
    requestPasswordReset,
    createAccount,
    createPasswordResetToken,
    getPasswordResetToken,
  }
}

describe('RequestPasswordResetCommand', () => {
  test('should delete existing tokens and create a new one', async ({ dbConnection }) => {
    const { requestPasswordReset, createAccount, createPasswordResetToken, getPasswordResetToken } =
      setup(dbConnection)
    const account = await createAccount({ username: 'test', password: 'password' })

    // Create an existing token
    const existingToken = await createPasswordResetToken(account.id)

    const newRawToken = await requestPasswordReset.execute(account.id)

    // Check that the old token was deleted
    expect(await getPasswordResetToken(existingToken.tokenHash)).toBeUndefined()

    // Check that a new token was created
    const newToken = await getPasswordResetToken(await new Sha256HashRepository().hash(newRawToken))
    expect(newToken).toBeDefined()
    expect(newToken?.accountId).toBe(account.id)
  })

  test('should create a token that expires in 2 hours', async ({ dbConnection }) => {
    const { requestPasswordReset, createAccount } = setup(dbConnection)
    const account = await createAccount({ username: 'test', password: 'password' })

    const token = await requestPasswordReset.execute(account.id)

    const hashedToken = await new Sha256HashRepository().hash(token)
    const createdToken = await new DrizzlePasswordResetTokenRepository(
      dbConnection,
    ).findByTokenHash(hashedToken)

    const now = new Date()
    const twoHoursLater = new Date(now.getTime() + 2 * 60 * 60 * 1000)

    expect(createdToken?.expiresAt.getTime()).toBeGreaterThan(now.getTime())
    expect(createdToken?.expiresAt.getTime()).toBeLessThanOrEqual(twoHoursLater.getTime())
  })

  test('should generate a token of correct length', async ({ dbConnection }) => {
    const { requestPasswordReset, createAccount } = setup(dbConnection)
    const account = await createAccount({ username: 'test', password: 'password' })

    const token = await requestPasswordReset.execute(account.id)

    expect(token.length).toBe(40) // The CryptoTokenGenerator is set to generate 40-character tokens
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/request-password-reset.ts
Contents:
import { createDate, TimeSpan } from 'oslo'

import type { HashRepository } from '../../../common/domain/repositories/hash'
import { PasswordResetToken } from '../../domain/entities/password-reset-token'
import { InvalidTokenLengthError } from '../../domain/errors/invalid-token-length'
import type { PasswordResetTokenRepository } from '../../domain/repositories/password-reset-token'
import type { TokenGenerator } from '../../domain/repositories/token-generator'

export class RequestPasswordResetCommand {
  constructor(
    private passwordResetTokenRepo: PasswordResetTokenRepository,
    private passwordResetTokenGeneratorRepo: TokenGenerator,
    private passwordResetTokenHashRepo: HashRepository,
  ) {}

  async execute(accountId: number): Promise<string> {
    await this.passwordResetTokenRepo.deleteByAccountId(accountId)

    const token = this.passwordResetTokenGeneratorRepo.generate(40)
    if (token instanceof InvalidTokenLengthError) {
      throw token // should never happen
    }

    const passwordResetToken = new PasswordResetToken(
      accountId,
      await this.passwordResetTokenHashRepo.hash(token),
      createDate(new TimeSpan(2, 'h')),
    )

    await this.passwordResetTokenRepo.create(passwordResetToken)

    return token
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/reset-password.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { Sha256HashRepository } from '../../../common/infrastructure/repositories/hash/sha256-hash-repository'
import { NewAccount } from '../../domain/entities/account'
import { Cookie } from '../../domain/entities/cookie'
import { PasswordResetToken } from '../../domain/entities/password-reset-token'
import { NonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { DrizzlePasswordResetTokenRepository } from '../../infrastructure/password-reset-token/drizzle-password-reset-token-repository'
import { createLucia } from '../../infrastructure/session/lucia'
import { LuciaSessionRepository } from '../../infrastructure/session/lucia-session-repository'
import { AccountNotFoundError } from '../errors/account-not-found'
import { InvalidLoginError } from '../errors/invalid-login'
import { LoginCommand } from './login'
import { ResetPasswordCommand } from './reset-password'

function setupCommand(options: { dbConnection: IDrizzleConnection }) {
  const accountRepo = new DrizzleAccountRepository(options.dbConnection)
  const sessionRepo = new LuciaSessionRepository(createLucia(options.dbConnection))
  const passwordResetTokenRepo = new DrizzlePasswordResetTokenRepository(options.dbConnection)
  const passwordHashRepo = new BcryptHashRepository()

  const resetPassword = new ResetPasswordCommand(
    accountRepo,
    sessionRepo,
    passwordResetTokenRepo,
    passwordHashRepo,
  )

  async function createAccount(data: { username: string; password: string }) {
    const account = await accountRepo.create(
      new NewAccount({
        username: data.username,
        passwordHash: await passwordHashRepo.hash(data.password),
      }),
    )

    if (account instanceof NonUniqueUsernameError) {
      expect.fail('Account creation failed due to non-unique username')
    }

    return account
  }

  async function loginAccount(data: { username: string; password: string }) {
    const login = new LoginCommand(accountRepo, sessionRepo, passwordHashRepo)
    const result = await login.execute(data.username, data.password)
    return result
  }

  async function getAccountSessions(username: string) {
    const account = await accountRepo.findByUsername(username)
    if (!account) return []

    const sessions = await sessionRepo.findByAccountId(account.id)
    return sessions
  }

  async function createPasswordResetToken(accountId: number) {
    const passwordResetTokenHashRepo = new Sha256HashRepository()

    const token = 'valid_token'
    const tokenHash = await passwordResetTokenHashRepo.hash(token)
    const expiresAt = new Date(Date.now() + 3600000) // 1 hour from now

    const passwordResetToken = new PasswordResetToken(accountId, tokenHash, expiresAt)

    await passwordResetTokenRepo.create(passwordResetToken)

    return passwordResetToken
  }

  async function getPasswordResetToken(tokenHash: string) {
    return await passwordResetTokenRepo.findByTokenHash(tokenHash)
  }

  return {
    resetPassword,
    createAccount,
    loginAccount,
    getAccountSessions,
    createPasswordResetToken,
    getPasswordResetToken,
  }
}

describe('resetPassword', () => {
  test('should successfully reset password', async ({ dbConnection }) => {
    const { resetPassword, createAccount, createPasswordResetToken, loginAccount } = setupCommand({
      dbConnection,
    })
    const account = await createAccount({ username: 'testaccount', password: 'oldpassword' })
    const passwordResetToken = await createPasswordResetToken(account.id)

    const result = await resetPassword.execute(passwordResetToken, 'newpassword')

    expect(result).toBeInstanceOf(Cookie)

    // Try to login with the new password
    const loginResult = await loginAccount({ username: 'testaccount', password: 'newpassword' })
    expect(loginResult).toBeInstanceOf(Cookie)

    // Try to login with the old password (should fail)
    const oldPasswordLoginResult = await loginAccount({
      username: 'testaccount',
      password: 'oldpassword',
    })
    expect(oldPasswordLoginResult).toBeInstanceOf(InvalidLoginError)
  })

  test('should return AccountNotFoundError for non-existent account', async ({ dbConnection }) => {
    const { resetPassword } = setupCommand({ dbConnection })
    const passwordResetToken = new PasswordResetToken(999, 'valid_token', new Date())

    const result = await resetPassword.execute(passwordResetToken, 'newpassword')

    expect(result).toBeInstanceOf(AccountNotFoundError)
  })

  test('should delete all current sessions for the account after password reset', async ({
    dbConnection,
  }) => {
    const {
      resetPassword,
      createAccount,
      createPasswordResetToken,
      loginAccount,
      getAccountSessions,
    } = setupCommand({
      dbConnection,
    })
    const account = await createAccount({ username: 'testaccount', password: 'oldpassword' })
    const passwordResetToken = await createPasswordResetToken(account.id)

    // Create multiple sessions for the account
    await loginAccount({ username: 'testaccount', password: 'oldpassword' })
    await loginAccount({ username: 'testaccount', password: 'oldpassword' })
    const preResetSessions = await getAccountSessions('testaccount')
    expect(preResetSessions).toHaveLength(2)

    // Reset the password
    await resetPassword.execute(passwordResetToken, 'newpassword')

    // Check if all current sessions for the account were deleted (except for the new one)
    const postResetSessions = await getAccountSessions('testaccount')
    expect(postResetSessions).toHaveLength(1)
  })

  test('should delete the password reset token after successful reset', async ({
    dbConnection,
  }) => {
    const { resetPassword, createAccount, createPasswordResetToken, getPasswordResetToken } =
      setupCommand({
        dbConnection,
      })
    const account = await createAccount({ username: 'testaccount', password: 'oldpassword' })
    const passwordResetToken = await createPasswordResetToken(account.id)

    await resetPassword.execute(passwordResetToken, 'newpassword')

    const storedToken = await getPasswordResetToken(passwordResetToken.tokenHash)
    expect(storedToken).toBeUndefined()
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/reset-password.ts
Contents:
import type { HashRepository } from '../../../common/domain/repositories/hash'
import type { Cookie } from '../../domain/entities/cookie'
import type { PasswordResetToken } from '../../domain/entities/password-reset-token'
import { NewSession } from '../../domain/entities/session'
import type { AccountRepository } from '../../domain/repositories/account'
import type { PasswordResetTokenRepository } from '../../domain/repositories/password-reset-token'
import type { SessionRepository } from '../../domain/repositories/session'
import { AccountNotFoundError } from '../errors/account-not-found'

export class ResetPasswordCommand {
  constructor(
    private accountRepo: AccountRepository,
    private sessionRepo: SessionRepository,
    private passwordResetTokenRepo: PasswordResetTokenRepository,
    private passwordHashRepo: HashRepository,
  ) {}

  async execute(
    passwordResetToken: PasswordResetToken,
    newPassword: string,
  ): Promise<Cookie | AccountNotFoundError> {
    const account = await this.accountRepo.findById(passwordResetToken.accountId)
    if (!account) {
      return new AccountNotFoundError(passwordResetToken.accountId)
    }

    const updatedAccount = account.resetPassword(await this.passwordHashRepo.hash(newPassword))
    await this.accountRepo.update(passwordResetToken.accountId, updatedAccount)

    // Sign out the account everywhere
    await this.sessionRepo.deleteAllForAccount(passwordResetToken.accountId)

    await this.passwordResetTokenRepo.deleteByTokenHash(passwordResetToken.tokenHash)

    const session = await this.sessionRepo.create(new NewSession(account.id))

    const cookie = this.sessionRepo.createCookie(session.id)

    return cookie
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/validate-password-reset-token.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { Sha256HashRepository } from '../../../common/infrastructure/repositories/hash/sha256-hash-repository'
import { NewAccount } from '../../domain/entities/account'
import { PasswordResetToken } from '../../domain/entities/password-reset-token'
import { NonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { DrizzlePasswordResetTokenRepository } from '../../infrastructure/password-reset-token/drizzle-password-reset-token-repository'
import { PasswordResetTokenExpiredError } from '../errors/password-reset-token-expired'
import { PasswordResetTokenNotFoundError } from '../errors/password-reset-token-not-found'
import { ValidatePasswordResetTokenCommand } from './validate-password-reset-token'

function setupCommand(options: { dbConnection: IDrizzleConnection }) {
  const passwordResetTokenRepo = new DrizzlePasswordResetTokenRepository(options.dbConnection)
  const passwordResetTokenHashRepo = new Sha256HashRepository()

  const validatePasswordResetToken = new ValidatePasswordResetTokenCommand(
    passwordResetTokenRepo,
    passwordResetTokenHashRepo,
  )

  async function createAccount(data: { username: string; password: string }) {
    const accountRepo = new DrizzleAccountRepository(options.dbConnection)
    const passwordHashRepo = new BcryptHashRepository()

    const account = await accountRepo.create(
      new NewAccount({
        username: data.username,
        passwordHash: await passwordHashRepo.hash(data.password),
      }),
    )

    if (account instanceof NonUniqueUsernameError) {
      expect.fail('Account creation failed due to non-unique username')
    }

    return account
  }

  async function createPasswordResetToken(accountId: number, expiresAt?: Date) {
    const passwordResetTokenHashRepo = new Sha256HashRepository()

    const unhashedToken = 'valid_token'
    const tokenHash = await passwordResetTokenHashRepo.hash(unhashedToken)

    const passwordResetToken = new PasswordResetToken(
      accountId,
      tokenHash,
      expiresAt ?? new Date(Date.now() + 3600000), // 1 hour from now
    )

    await passwordResetTokenRepo.create(passwordResetToken)

    return { unhashedToken, passwordResetToken }
  }

  return { validatePasswordResetToken, createAccount, createPasswordResetToken }
}

describe('checkPasswordResetToken', () => {
  test('should return valid PasswordResetToken for a valid token', async ({ dbConnection }) => {
    const { validatePasswordResetToken, createAccount, createPasswordResetToken } = setupCommand({
      dbConnection,
    })

    const account = await createAccount({ username: 'testuser', password: 'password123' })
    const { unhashedToken, passwordResetToken } = await createPasswordResetToken(account.id)

    const result = await validatePasswordResetToken.execute(unhashedToken)

    expect(result).toBeInstanceOf(PasswordResetToken)
    expect((result as PasswordResetToken).accountId).toBe(passwordResetToken.accountId)
    expect((result as PasswordResetToken).tokenHash).toBe(passwordResetToken.tokenHash)
    expect((result as PasswordResetToken).expiresAt).toEqual(passwordResetToken.expiresAt)
  })

  test('should return PasswordResetTokenNotFoundError for a non-existent token', async ({
    dbConnection,
  }) => {
    const { validatePasswordResetToken } = setupCommand({ dbConnection })

    const result = await validatePasswordResetToken.execute('non_existent_token')

    expect(result).toBeInstanceOf(PasswordResetTokenNotFoundError)
  })

  test('should return ExpiredPasswordResetTokenError for an expired token', async ({
    dbConnection,
  }) => {
    const { validatePasswordResetToken, createAccount, createPasswordResetToken } = setupCommand({
      dbConnection,
    })

    const account = await createAccount({ username: 'testuser', password: 'password123' })
    const { unhashedToken } = await createPasswordResetToken(
      account.id,
      new Date(Date.now() - 1000), // Expired 1 second ago
    )

    // Check the token
    const result = await validatePasswordResetToken.execute(unhashedToken)

    expect(result).toBeInstanceOf(PasswordResetTokenExpiredError)
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/validate-password-reset-token.ts
Contents:
import type { HashRepository } from '../../../common/domain/repositories/hash'
import type { PasswordResetToken } from '../../domain/entities/password-reset-token'
import type { PasswordResetTokenRepository } from '../../domain/repositories/password-reset-token'
import { PasswordResetTokenExpiredError } from '../errors/password-reset-token-expired'
import { PasswordResetTokenNotFoundError } from '../errors/password-reset-token-not-found'

export class ValidatePasswordResetTokenCommand {
  constructor(
    private passwordResetTokenRepo: PasswordResetTokenRepository,
    private passwordResetTokenHashRepo: HashRepository,
  ) {}

  async execute(
    verificationToken: string,
  ): Promise<
    PasswordResetToken | PasswordResetTokenNotFoundError | PasswordResetTokenExpiredError
  > {
    const tokenHash = await this.passwordResetTokenHashRepo.hash(verificationToken)
    const token = await this.passwordResetTokenRepo.findByTokenHash(tokenHash)

    if (!token) {
      return new PasswordResetTokenNotFoundError()
    }

    if (token.isExpired()) {
      return new PasswordResetTokenExpiredError()
    }

    return token
  }
}

---

File: ./src/lib/server/features/authentication/application/commands/validate-session.test.ts
Contents:
import { describe, expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'

import { test } from '../../../../../../vitest-setup'
import { NewAccount } from '../../domain/entities/account'
import { Cookie } from '../../domain/entities/cookie'
import { NewSession } from '../../domain/entities/session'
import { NonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { DrizzleAccountRepository } from '../../infrastructure/account/drizzle-account-repository'
import { BcryptHashRepository } from '../../infrastructure/hash/bcrypt-hash-repository'
import { createLucia } from '../../infrastructure/session/lucia'
import { LuciaSessionRepository } from '../../infrastructure/session/lucia-session-repository'
import { ValidateSessionCommand } from './validate-session'

function setupCommand(options: { dbConnection: IDrizzleConnection }) {
  const accountRepo = new DrizzleAccountRepository(options.dbConnection)
  const sessionRepo = new LuciaSessionRepository(createLucia(options.dbConnection))

  const validateSession = new ValidateSessionCommand(accountRepo, sessionRepo)

  async function createAccount(data: { username: string; password: string }) {
    const passwordHashRepo = new BcryptHashRepository()

    const account = await accountRepo.create(
      new NewAccount({
        username: data.username,
        passwordHash: await passwordHashRepo.hash(data.password),
      }),
    )

    if (account instanceof NonUniqueUsernameError) {
      expect.fail('Account creation failed due to non-unique username')
    }

    return account
  }

  async function createSession(accountId: number) {
    const session = new NewSession(accountId)
    const sessionId = await sessionRepo.create(session)
    return sessionId
  }

  return { validateSession, createAccount, createSession }
}

describe('validateSession', () => {
  test('should return undefined values when sessionId is undefined', async ({ dbConnection }) => {
    const { validateSession } = setupCommand({ dbConnection })

    const result = await validateSession.execute(undefined)

    expect(result.account).toBeUndefined()
    expect(result.session).toBeUndefined()
    expect(result.cookie).toBeUndefined()
  })

  test('should return cookie to clear session when session is not found', async ({
    dbConnection,
  }) => {
    const { validateSession } = setupCommand({ dbConnection })

    const result = await validateSession.execute('non_existent_session_id')

    expect(result.account).toBeUndefined()
    expect(result.session).toBeUndefined()
    expect(result.cookie).toBeInstanceOf(Cookie)
    expect(result.cookie?.value).toBe('')
  })

  test('should return account, session, and new cookie when session is valid and just extended', async ({
    dbConnection,
    withSystemTime,
  }) => {
    const { validateSession, createAccount, createSession } = setupCommand({ dbConnection })

    const account = await createAccount({ username: 'testuser', password: 'password123' })
    const session = await createSession(account.id)

    // 16 days in the future
    withSystemTime(new Date(Date.now() + 16 * 24 * 60 * 60 * 1000))

    const result = await validateSession.execute(session.id)

    expect(result.account).toBeDefined()
    expect(result.account?.username).toBe('testuser')
    expect(result.session).toBeDefined()
    expect(result.session?.id).toBe(session.id)
    expect(result.session?.wasJustExtended).toBe(true)
    expect(result.cookie).toBeInstanceOf(Cookie)
    expect(result.cookie?.value).toBe(session.id)
  })

  test('should return account and session without cookie when session is valid but not extended', async ({
    dbConnection,
  }) => {
    const { validateSession, createAccount, createSession } = setupCommand({ dbConnection })

    const account = await createAccount({ username: 'testuser', password: 'password123' })
    const session = await createSession(account.id)

    const result = await validateSession.execute(session.id)

    expect(result.account).toBeDefined()
    expect(result.account?.username).toBe('testuser')
    expect(result.session).toBeDefined()
    expect(result.session?.id).toBe(session.id)
    expect(result.session?.wasJustExtended).toBe(false)
    expect(result.cookie).toBeUndefined()
  })
})

---

File: ./src/lib/server/features/authentication/application/commands/validate-session.ts
Contents:
import type { CreatedAccount } from '../../domain/entities/account'
import type { Cookie } from '../../domain/entities/cookie'
import type { CreatedSession } from '../../domain/entities/session'
import type { AccountRepository } from '../../domain/repositories/account'
import type { SessionRepository } from '../../domain/repositories/session'

export class ValidateSessionCommand {
  constructor(
    private accountRepo: AccountRepository,
    private sessionRepo: SessionRepository,
  ) {}

  async execute(sessionId: string | undefined): Promise<{
    account: CreatedAccount | undefined
    session: CreatedSession | undefined
    cookie: Cookie | undefined
  }> {
    if (!sessionId) {
      return { account: undefined, session: undefined, cookie: undefined }
    }

    const session = await this.sessionRepo.findById(sessionId)

    if (!session) {
      // Session was not found, clear the cookie
      const cookie = this.sessionRepo.createCookie(undefined)
      return { account: undefined, session: undefined, cookie }
    }

    const account = await this.accountRepo.findById(session.accountId)
    if (!account) {
      // Session was found, but account was not, clear the cookie
      const cookie = this.sessionRepo.createCookie(undefined)
      return { account: undefined, session: undefined, cookie }
    }

    if (session.wasJustExtended) {
      // Session was found and extended, update the cookie
      const cookie = this.sessionRepo.createCookie(session.id)
      return { account, session, cookie }
    }

    // Session was found and doesn't need updated
    return { account, session, cookie: undefined }
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/account-not-found.ts
Contents:
import { ApplicationError } from './base'

export class AccountNotFoundError extends ApplicationError {
  constructor(public accountId: number) {
    super('AccountNotFoundError', 'Account not found')
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/base.ts
Contents:
import { CustomError } from '$lib/utils/error'

export class ApplicationError extends CustomError {
  private readonly __tag = 'ApplicationError'

  constructor(name: string, message: string) {
    super(name, message)
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/invalid-login.ts
Contents:
import { ApplicationError } from './base'

export class InvalidLoginError extends ApplicationError {
  constructor() {
    super('InvalidLogin', 'Incorrect username or password')
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/non-unique-username.ts
Contents:
import { ApplicationError } from './base'

export class NonUniqueUsernameError extends ApplicationError {
  constructor(public username: string) {
    super('NonUniqueUsernameError', 'Username is already taken')
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/password-reset-token-expired.ts
Contents:
import { ApplicationError } from './base'

export class PasswordResetTokenExpiredError extends ApplicationError {
  constructor() {
    super('PasswordResetTokenExpiredError', 'Password reset token has expired')
  }
}

---

File: ./src/lib/server/features/authentication/application/errors/password-reset-token-not-found.ts
Contents:
import { ApplicationError } from './base'

export class PasswordResetTokenNotFoundError extends ApplicationError {
  constructor() {
    super('PasswordResetTokenNotFoundError', 'Password reset token not found')
  }
}

---

File: ./src/lib/server/features/authentication/domain/entities/account.ts
Contents:
export type Permission = 'EDIT_GENRES' | 'EDIT_RELEASES' | 'EDIT_ARTISTS'

export type AccountProps = {
  username: string
  passwordHash: string
  darkMode?: boolean
  permissions?: Set<Permission>
  genreRelevanceFilter?: number
  showRelevanceTags?: boolean
  showTypeTags?: boolean
  showNsfw?: boolean
  createdAt?: Date
  updatedAt?: Date
}

export class NewAccount {
  public username: string
  public passwordHash: string
  public darkMode: boolean
  public permissions: Set<Permission>
  public genreRelevanceFilter: number
  public showRelevanceTags: boolean
  public showTypeTags: boolean
  public showNsfw: boolean
  public createdAt: Date
  public updatedAt: Date

  constructor(props: AccountProps) {
    this.username = props.username
    this.passwordHash = props.passwordHash
    this.darkMode = props.darkMode ?? true
    this.permissions = props.permissions ?? new Set()
    this.genreRelevanceFilter = props.genreRelevanceFilter ?? 0
    this.showRelevanceTags = props.showRelevanceTags ?? false
    this.showTypeTags = props.showTypeTags ?? true
    this.showNsfw = props.showNsfw ?? false
    this.createdAt = props.createdAt ?? new Date()
    this.updatedAt = props.updatedAt ?? new Date()
  }

  resetPassword(newPasswordHash: string): NewAccount {
    return new NewAccount({
      ...this,
      passwordHash: newPasswordHash,
      updatedAt: new Date(),
    })
  }

  unmarshal(): AccountProps {
    return {
      username: this.username,
      passwordHash: this.passwordHash,
      darkMode: this.darkMode,
      permissions: this.permissions,
      genreRelevanceFilter: this.genreRelevanceFilter,
      showRelevanceTags: this.showRelevanceTags,
      showTypeTags: this.showTypeTags,
      showNsfw: this.showNsfw,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    }
  }
}

export class CreatedAccount extends NewAccount {
  public readonly id: number

  constructor(id: number, props: AccountProps) {
    super(props)
    this.id = id
  }

  unmarshal(): AccountProps & { id: number } {
    return {
      ...super.unmarshal(),
      id: this.id,
    }
  }
}

---

File: ./src/lib/server/features/authentication/domain/entities/cookie.ts
Contents:
export class Cookie {
  constructor(
    public name: string,
    public value: string,
    public attributes: CookieAttributes,
  ) {}
}

type CookieAttributes = {
  secure?: boolean
  path?: string
  domain?: string
  sameSite?: 'lax' | 'strict' | 'none'
  httpOnly?: boolean
  maxAge?: number
  expires?: Date
}

---

File: ./src/lib/server/features/authentication/domain/entities/password-reset-token.ts
Contents:
export class PasswordResetToken {
  constructor(
    public accountId: number,
    public tokenHash: string,
    public expiresAt: Date,
  ) {}

  isExpired() {
    return Date.now() >= this.expiresAt.getTime()
  }
}

---

File: ./src/lib/server/features/authentication/domain/entities/session.ts
Contents:
export class NewSession {
  constructor(public accountId: number) {}
}

export class CreatedSession extends NewSession {
  constructor(
    public id: string,
    public accountId: number,
    public wasJustExtended = false,
  ) {
    super(accountId)
  }
}

---

File: ./src/lib/server/features/authentication/domain/errors/base.ts
Contents:
import { CustomError } from '$lib/utils/error'

export class DomainError extends CustomError {
  private readonly __tag = 'DomainError'

  constructor(name: string, message: string) {
    super(name, message)
  }
}

---

File: ./src/lib/server/features/authentication/domain/errors/invalid-token-length.ts
Contents:
import { DomainError } from './base'

export class InvalidTokenLengthError extends DomainError {
  constructor(public length: number) {
    super('InvalidTokenLength', `Invalid token length: ${length}. Must be a positive integer.`)
  }
}

---

File: ./src/lib/server/features/authentication/domain/errors/non-unique-username.ts
Contents:
import { DomainError } from './base'

export class NonUniqueUsernameError extends DomainError {
  constructor(public username: string) {
    super('NonUniqueUsernameError', 'Username is already taken')
  }
}

---

File: ./src/lib/server/features/authentication/domain/repositories/account.ts
Contents:
import type { CreatedAccount, NewAccount } from '../entities/account'
import type { NonUniqueUsernameError } from '../errors/non-unique-username'

export type AccountRepository = {
  findById(id: number): Promise<CreatedAccount | undefined>
  findByUsername(username: string): Promise<CreatedAccount | undefined>
  create(account: NewAccount): Promise<CreatedAccount | NonUniqueUsernameError>
  update(id: number, account: NewAccount): Promise<void>
}

---

File: ./src/lib/server/features/authentication/domain/repositories/password-reset-token.ts
Contents:
import type { PasswordResetToken } from '../entities/password-reset-token'

export type PasswordResetTokenRepository = {
  create(token: PasswordResetToken): Promise<void>
  findByTokenHash(tokenHash: string): Promise<PasswordResetToken | undefined>
  deleteByTokenHash(tokenHash: string): Promise<void>
  deleteByAccountId(accountId: number): Promise<void>
}

---

File: ./src/lib/server/features/authentication/domain/repositories/session.ts
Contents:
import type { Cookie } from '../entities/cookie'
import type { CreatedSession, NewSession } from '../entities/session'

export type SessionRepository = {
  findById(sessionId: string): Promise<CreatedSession | undefined>
  findByAccountId(accountId: number): Promise<CreatedSession[]>

  create(session: NewSession): Promise<CreatedSession>
  delete(sessionId: string): Promise<void>
  deleteAllForAccount(accountId: number): Promise<void>

  createCookie(sessionId: string | undefined): Cookie
}

---

File: ./src/lib/server/features/authentication/domain/repositories/token-generator.ts
Contents:
import type { InvalidTokenLengthError } from '../errors/invalid-token-length'

export type TokenGenerator = {
  generate(length: number): string | InvalidTokenLengthError
}

---

File: ./src/lib/server/features/authentication/infrastructure/account/drizzle-account-repository.ts
Contents:
import { eq } from 'drizzle-orm'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import { accounts } from '$lib/server/db/schema'

import type { NewAccount } from '../../domain/entities/account'
import { CreatedAccount } from '../../domain/entities/account'
import { NonUniqueUsernameError } from '../../domain/errors/non-unique-username'
import { type AccountRepository } from '../../domain/repositories/account'

export class DrizzleAccountRepository implements AccountRepository {
  constructor(private db: IDrizzleConnection) {}

  async findById(id: number): Promise<CreatedAccount | undefined> {
    const entry = await this.db.query.accounts.findFirst({
      where: (accounts, { eq }) => eq(accounts.id, id),
    })
    if (!entry) return

    const account = new CreatedAccount(entry.id, {
      username: entry.username,
      passwordHash: entry.password,
      darkMode: entry.darkMode,
      permissions: new Set(entry.permissions ?? []),
      genreRelevanceFilter: entry.genreRelevanceFilter,
      showRelevanceTags: entry.showRelevanceTags,
      showTypeTags: entry.showTypeTags,
      showNsfw: entry.showNsfw,
      createdAt: entry.createdAt,
      updatedAt: entry.updatedAt,
    })

    return account
  }

  async findByUsername(username: string): Promise<CreatedAccount | undefined> {
    const entry = await this.db.query.accounts.findFirst({
      where: (accounts, { eq }) => eq(accounts.username, username),
    })
    if (!entry) return

    const account = new CreatedAccount(entry.id, {
      username: entry.username,
      passwordHash: entry.password,
      darkMode: entry.darkMode,
      permissions: new Set(entry.permissions ?? []),
      genreRelevanceFilter: entry.genreRelevanceFilter,
      showRelevanceTags: entry.showRelevanceTags,
      showTypeTags: entry.showTypeTags,
      showNsfw: entry.showNsfw,
      createdAt: entry.createdAt,
      updatedAt: entry.updatedAt,
    })

    return account
  }

  async create(account: NewAccount): Promise<CreatedAccount | NonUniqueUsernameError> {
    try {
      const [{ accountId }] = await this.db
        .insert(accounts)
        .values([
          {
            username: account.username,
            password: account.passwordHash,
            darkMode: account.darkMode,
            permissions: [...account.permissions],
            genreRelevanceFilter: account.genreRelevanceFilter,
            showRelevanceTags: account.showRelevanceTags,
            showTypeTags: account.showTypeTags,
            showNsfw: account.showNsfw,
            createdAt: account.createdAt,
            updatedAt: account.updatedAt,
          },
        ])
        .returning({ accountId: accounts.id })

      return new CreatedAccount(accountId, account)
    } catch (error) {
      if (isPostgresError(error, '23505', 'Account_username_unique')) {
        return new NonUniqueUsernameError(account.username)
      }
      throw error
    }
  }

  async update(id: number, account: NewAccount): Promise<void> {
    await this.db
      .update(accounts)
      .set({
        username: account.username,
        password: account.passwordHash,
        darkMode: account.darkMode,
        permissions: [...account.permissions],
        genreRelevanceFilter: account.genreRelevanceFilter,
        showRelevanceTags: account.showRelevanceTags,
        showTypeTags: account.showTypeTags,
        showNsfw: account.showNsfw,
        updatedAt: account.updatedAt,
      })
      .where(eq(accounts.id, id))
  }
}

function isPostgresError(error: unknown, code: string, constraint: string): boolean {
  return (
    typeof error === 'object' &&
    error !== null &&
    'code' in error &&
    error.code === code &&
    (('constraint' in error && error.constraint === constraint) ||
      ('constraint_name' in error && error.constraint_name === constraint))
  )
}

---

File: ./src/lib/server/features/authentication/infrastructure/hash/bcrypt-hash-repository.ts
Contents:
import bcryptjs from 'bcryptjs'

import type { HashRepository } from '../../../common/domain/repositories/hash'

export class BcryptHashRepository implements HashRepository {
  hash(input: string): Promise<string> {
    return bcryptjs.hash(input, 12)
  }

  compare(input: string, hash: string): Promise<boolean> {
    return bcryptjs.compare(input, hash)
  }
}

---

File: ./src/lib/server/features/authentication/infrastructure/password-reset-token/drizzle-password-reset-token-repository.ts
Contents:
import { eq } from 'drizzle-orm'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import { passwordResetTokens } from '$lib/server/db/schema'

import { PasswordResetToken } from '../../domain/entities/password-reset-token'
import type { PasswordResetTokenRepository } from '../../domain/repositories/password-reset-token'

export class DrizzlePasswordResetTokenRepository implements PasswordResetTokenRepository {
  constructor(private db: IDrizzleConnection) {}

  async create(token: PasswordResetToken): Promise<void> {
    await this.db.insert(passwordResetTokens).values({
      tokenHash: token.tokenHash,
      userId: token.accountId,
      expiresAt: token.expiresAt,
    })
  }

  async findByTokenHash(tokenHash: string): Promise<PasswordResetToken | undefined> {
    const entry = await this.db.query.passwordResetTokens.findFirst({
      where: (passwordResetTokens, { eq }) => eq(passwordResetTokens.tokenHash, tokenHash),
    })
    if (!entry) return

    const token = new PasswordResetToken(entry.userId, entry.tokenHash, entry.expiresAt)

    return token
  }

  async deleteByTokenHash(tokenHash: string): Promise<void> {
    await this.db.delete(passwordResetTokens).where(eq(passwordResetTokens.tokenHash, tokenHash))
  }

  async deleteByAccountId(accountId: number): Promise<void> {
    await this.db.delete(passwordResetTokens).where(eq(passwordResetTokens.userId, accountId))
  }
}

---

File: ./src/lib/server/features/authentication/infrastructure/session/lucia-session-repository.ts
Contents:
import { Cookie } from '../../domain/entities/cookie'
import type { NewSession } from '../../domain/entities/session'
import { CreatedSession } from '../../domain/entities/session'
import type { SessionRepository } from '../../domain/repositories/session'
import type { AppLucia } from './lucia'

export class LuciaSessionRepository implements SessionRepository {
  constructor(private lucia: AppLucia) {}

  async findById(sessionId: string): Promise<CreatedSession | undefined> {
    const { session } = await this.lucia.validateSession(sessionId)
    if (!session) return
    return new CreatedSession(session.id, session.userId, session.fresh)
  }

  async findByAccountId(accountId: number): Promise<CreatedSession[]> {
    const sessions = await this.lucia.getUserSessions(accountId)
    return sessions.map((session) => new CreatedSession(session.id, session.userId, session.fresh))
  }

  async create(session: NewSession): Promise<CreatedSession> {
    const output = await this.lucia.createSession(session.accountId, {})
    return new CreatedSession(output.id, output.userId, output.fresh)
  }

  async delete(sessionId: string): Promise<void> {
    await this.lucia.invalidateSession(sessionId)
  }

  async deleteAllForAccount(accountId: number): Promise<void> {
    await this.lucia.invalidateUserSessions(accountId)
  }

  createCookie(sessionId: string | undefined): Cookie {
    const sessionCookie =
      sessionId === undefined
        ? this.lucia.createBlankSessionCookie()
        : this.lucia.createSessionCookie(sessionId)

    return new Cookie(sessionCookie.name, sessionCookie.value, sessionCookie.attributes)
  }
}

---

File: ./src/lib/server/features/authentication/infrastructure/session/lucia.ts
Contents:
import { DrizzlePostgreSQLAdapter } from '@lucia-auth/adapter-drizzle'
import type { InferSelectModel } from 'drizzle-orm'
import type { PgDatabase } from 'drizzle-orm/pg-core'
import { Lucia } from 'lucia'
import { omit } from 'ramda'

import { accounts, sessions } from '$lib/server/db/schema'

declare module 'lucia' {
  // eslint-disable-next-line @typescript-eslint/consistent-type-definitions
  interface Register {
    Lucia: AppLucia
    UserId: number
    DatabaseUserAttributes: DatabaseUserAttributes
  }
}

type DatabaseUserAttributes = InferSelectModel<typeof accounts>

export type AppLucia = ReturnType<typeof createLucia>

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const createLucia = (db: PgDatabase<any, any, any>) => {
  const adapter = new DrizzlePostgreSQLAdapter(db, sessions, accounts)

  const lucia = new Lucia(adapter, {
    sessionCookie: {
      name: 'auth_session',
      attributes: {
        // set to `true` when using HTTPS
        secure: process.env.NODE_ENV === 'production',
      },
    },
    getUserAttributes: (attributes) => {
      return omit(['password'], attributes)
    },
  })

  return lucia
}

---

File: ./src/lib/server/features/authentication/infrastructure/token/crypto-token-generator.test.ts
Contents:
import { describe, expect, it, vi } from 'vitest'

import { InvalidTokenLengthError } from '../../domain/errors/invalid-token-length'
import type { TokenGenerator } from '../../domain/repositories/token-generator'
import { CryptoTokenGenerator } from './crypto-token-generator'

describe('CryptoTokenGenerator', () => {
  function setup(): TokenGenerator {
    return new CryptoTokenGenerator()
  }

  it('should generate a string of the specified length', () => {
    const tokenGenerator = setup()
    const length = 16
    const result = tokenGenerator.generate(length)
    expect(result).toHaveLength(length)
  })

  it('should generate a string containing only hexadecimal characters', () => {
    const tokenGenerator = setup()
    const result = tokenGenerator.generate(32)
    expect(result).toMatch(/^[0-9a-f]+$/)
  })

  it('should generate different tokens on successive calls', () => {
    const tokenGenerator = setup()
    const firstToken = tokenGenerator.generate(16)
    const secondToken = tokenGenerator.generate(16)
    expect(firstToken).not.toBe(secondToken)
  })

  it('should handle very short lengths', () => {
    const tokenGenerator = setup()
    const result = tokenGenerator.generate(1)
    expect(result).toHaveLength(1)
    expect(result).toMatch(/^[0-9a-f]$/)
  })

  it('should handle odd lengths correctly', () => {
    const tokenGenerator = setup()
    const result = tokenGenerator.generate(15)
    expect(result).toHaveLength(15)
    expect(result).toMatch(/^[0-9a-f]+$/)
  })

  it('should throw an error for zero length', () => {
    const tokenGenerator = setup()
    expect(() => tokenGenerator.generate(0)).toThrowError(InvalidTokenLengthError)
  })

  it('should throw an error for negative length', () => {
    const tokenGenerator = setup()
    expect(() => tokenGenerator.generate(-5)).toThrowError(InvalidTokenLengthError)
  })

  it('should use crypto.getRandomValues', () => {
    const mockGetRandomValues = vi.spyOn(crypto, 'getRandomValues')
    const tokenGenerator = setup()
    tokenGenerator.generate(16)
    expect(mockGetRandomValues).toHaveBeenCalled()
  })
})

---

File: ./src/lib/server/features/authentication/infrastructure/token/crypto-token-generator.ts
Contents:
import { InvalidTokenLengthError } from '../../domain/errors/invalid-token-length'
import type { TokenGenerator } from '../../domain/repositories/token-generator'

export class CryptoTokenGenerator implements TokenGenerator {
  generate(length: number): string | InvalidTokenLengthError {
    if (length <= 0) {
      throw new InvalidTokenLengthError(length)
    }

    // Calculate the number of bytes needed
    const byteLength = Math.ceil(length / 2)

    // Generate random values
    const randomBytes = crypto.getRandomValues(new Uint8Array(byteLength))

    return Array.from(randomBytes, (byte) => byte.toString(16).padStart(2, '0'))
      .join('')
      .slice(0, length)
  }
}

---

File: ./src/lib/server/features/authentication/presentation/schemas/password.ts
Contents:
import { z } from 'zod'

export const passwordSchema = z
  .object({
    password: z.string().min(8).max(72),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Passwords do not match',
    path: ['confirmPassword'],
  })

---

File: ./src/lib/server/features/common/domain/repositories/hash.ts
Contents:
export type HashRepository = {
  hash(input: string): Promise<string>
  compare(input: string, hash: string): Promise<boolean>
}

---

File: ./src/lib/server/features/common/infrastructure/repositories/hash/sha256-hash-repository.ts
Contents:
import { sha256 } from 'oslo/crypto'
import { encodeHex } from 'oslo/encoding'

import type { HashRepository } from '../../../domain/repositories/hash'

export class Sha256HashRepository implements HashRepository {
  async hash(input: string): Promise<string> {
    return encodeHex(await sha256(new TextEncoder().encode(input)))
  }

  async compare(input: string, hash: string): Promise<boolean> {
    const hashedInput = await this.hash(input)
    return hashedInput === hash
  }
}

---

File: ./src/lib/server/features/genres/application/genre-service.test.ts
Contents:
import { expect } from 'vitest'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import { accounts, genreParents, genres } from '$lib/server/db/schema'

import { test } from '../../../../../vitest-setup'
import type { GenreConstructorParams } from '../domain/genre'
import { Genre } from '../domain/genre'
import { GenreHistory } from '../domain/genre-history'
import { DrizzleGenreRepository } from '../infrastructure/genre/drizzle-genre-repository'
import { DrizzleGenreHistoryRepository } from '../infrastructure/genre-history/drizzle-genre-history-repository'
import {
  GenreCycleError,
  GenreService,
  NotFoundError,
  NoUpdatesError,
  SelfInfluenceError,
} from './genre-service'

const createBasicGenre = (id: number, name: string): GenreConstructorParams => ({
  id,
  name,
  type: 'STYLE' as const,
  nsfw: false,
  relevance: 1,
  parents: new Set(),
  influences: new Set(),
  akas: {
    primary: [],
    secondary: [],
    tertiary: [],
  },
  createdAt: new Date(),
  updatedAt: new Date(),
})

const createTestAccount = async (dbConnection: IDrizzleConnection) => {
  const [{ accountId }] = await dbConnection
    .insert(accounts)
    .values([
      {
        username: 'testuser',
        password: 'hashedpassword',
        darkMode: true,
        genreRelevanceFilter: 0,
        showRelevanceTags: false,
        showTypeTags: true,
        showNsfw: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ])
    .returning({ accountId: accounts.id })
  return accountId
}

test('should update a genre successfully', async ({ dbConnection }) => {
  const genresRepo = new DrizzleGenreRepository(dbConnection)
  const genreHistoryRepo = new DrizzleGenreHistoryRepository(dbConnection)
  const genreService = new GenreService(genresRepo, genreHistoryRepo)

  const accountId = await createTestAccount(dbConnection)

  // Insert a genre
  await dbConnection.insert(genres).values(createBasicGenre(1, 'Original Genre'))

  const genreUpdate = { name: 'Updated Genre' }
  await genreService.updateGenre(1, genreUpdate, accountId) // Using 1 as the accountId of our test account

  const updatedGenre = await genresRepo.findById(1)
  expect(updatedGenre?.name).toBe('Updated Genre')

  const history = await genreHistoryRepo.findLatestByGenreId(1)
  expect(history?.name).toBe('Updated Genre')
  expect(history?.operation).toBe('UPDATE')
})

test('should throw NotFoundError if genre does not exist', async ({ dbConnection }) => {
  const genresRepo = new DrizzleGenreRepository(dbConnection)
  const genreHistoryRepo = new DrizzleGenreHistoryRepository(dbConnection)
  const genreService = new GenreService(genresRepo, genreHistoryRepo)

  const accountId = await createTestAccount(dbConnection)

  await expect(genreService.updateGenre(1, { name: 'New Name' }, accountId)).rejects.toThrow(
    NotFoundError,
  )
})

test('should throw SelfInfluenceError if genre influences itself', async ({ dbConnection }) => {
  const genresRepo = new DrizzleGenreRepository(dbConnection)
  const genreHistoryRepo = new DrizzleGenreHistoryRepository(dbConnection)
  const genreService = new GenreService(genresRepo, genreHistoryRepo)

  const accountId = await createTestAccount(dbConnection)

  // Insert a genre
  await dbConnection.insert(genres).values(createBasicGenre(1, 'Self-influencing Genre'))

  const genreUpdate = { influences: new Set([1]) }
  await expect(genreService.updateGenre(1, genreUpdate, accountId)).rejects.toThrow(
    SelfInfluenceError,
  )
})

test('should throw NoUpdatesError if no changes were made', async ({ dbConnection }) => {
  const genresRepo = new DrizzleGenreRepository(dbConnection)
  const genreHistoryRepo = new DrizzleGenreHistoryRepository(dbConnection)
  const genreService = new GenreService(genresRepo, genreHistoryRepo)

  const accountId = await createTestAccount(dbConnection)

  // Insert a genre
  const genreData = createBasicGenre(1, 'Unchanged Genre')
  await dbConnection.insert(genres).values(genreData)

  // Create an initial history entry
  const genre = new Genre(genreData)
  await genreHistoryRepo.create(GenreHistory.fromGenre(genre, 'CREATE', accountId))

  const genreUpdate = { name: 'Unchanged Genre' }
  await expect(genreService.updateGenre(1, genreUpdate, accountId)).rejects.toThrow(NoUpdatesError)
})

test('should throw GenreCycleError if a cycle is detected', async ({ dbConnection }) => {
  const genresRepo = new DrizzleGenreRepository(dbConnection)
  const genreHistoryRepo = new DrizzleGenreHistoryRepository(dbConnection)
  const genreService = new GenreService(genresRepo, genreHistoryRepo)

  const accountId = await createTestAccount(dbConnection)

  // Insert genres to create a potential cycle
  await dbConnection
    .insert(genres)
    .values([
      createBasicGenre(1, 'Genre A'),
      createBasicGenre(2, 'Genre B'),
      createBasicGenre(3, 'Genre C'),
    ])

  // Set up existing parent relationships
  await dbConnection.insert(genreParents).values([
    { childId: 2, parentId: 1 },
    { childId: 3, parentId: 2 },
  ])

  // Attempt to create a cycle by making Genre A a child of Genre C
  const genreUpdate = { parents: new Set([3]) }
  await expect(genreService.updateGenre(1, genreUpdate, accountId)).rejects.toThrow(GenreCycleError)
})

---

File: ./src/lib/server/features/genres/application/genre-service.ts
Contents:
import { type GenreUpdate } from '../domain/genre'
import { GenreHistory } from '../domain/genre-history'
import type { GenreRepository } from '../infrastructure/genre/genre-repository'
import type { GenreHistoryRepository } from '../infrastructure/genre-history/genre-history-repository'

export type CreateRelease = {
  title: string
  art?: string
  artists: number[]
  tracks: (number | { title: string; artists: number[] })[]
}

export class SelfInfluenceError extends Error {
  constructor() {
    super('A genre cannot influence itself')
  }
}

export class NotFoundError extends Error {
  constructor() {
    super('Genre not found')
  }
}

export class GenreCycleError extends Error {
  constructor(public cycle: string) {
    super(`Cycle detected: ${cycle}`)
  }
}

export class NoUpdatesError extends Error {
  constructor() {
    super('No updates were made')
  }
}

export class GenreService {
  constructor(
    private genreRepo: GenreRepository,
    private genreHistoryRepo: GenreHistoryRepository,
  ) {}

  async updateGenre(id: number, data: GenreUpdate, accountId: number): Promise<void> {
    const genre = await this.genreRepo.findById(id)
    if (!genre) {
      throw new NotFoundError()
    }

    const updatedGenre = genre.withUpdate(data)
    if (updatedGenre.hasSelfInfluence()) {
      throw new SelfInfluenceError()
    }

    const lastGenreHistory = await this.genreHistoryRepo.findLatestByGenreId(id)
    if (lastGenreHistory && !updatedGenre.isChangedFrom(lastGenreHistory)) {
      throw new NoUpdatesError()
    }

    const genreTree = await this.genreRepo.getGenreTree()
    genreTree.updateGenre(id, updatedGenre)

    const cycle = genreTree.findCycle()
    if (cycle) {
      throw new GenreCycleError(cycle)
    }

    await this.genreRepo.update(id, updatedGenre)

    const genreHistory = GenreHistory.fromGenre(updatedGenre, 'UPDATE', accountId)
    await this.genreHistoryRepo.create(genreHistory)
  }
}

---

File: ./src/lib/server/features/genres/domain/genre-history.ts
Contents:
import type { Genre } from './genre'

export class GenreHistory {
  constructor(
    public name: string,
    public subtitle: string | undefined,
    public type: 'TREND' | 'SCENE' | 'STYLE' | 'META' | 'MOVEMENT',
    public nsfw: boolean,
    public shortDescription: string | undefined,
    public longDescription: string | undefined,
    public notes: string | undefined,

    public parents: Set<number>,
    public influences: Set<number>,
    public akas: {
      primary: string[]
      secondary: string[]
      tertiary: string[]
    },

    public genreId: number,
    public createdAt: Date,
    public operation: 'CREATE' | 'UPDATE' | 'DELETE',
    public accountId: number | undefined,
  ) {}

  static fromGenre(genre: Genre, operation: 'CREATE' | 'UPDATE' | 'DELETE', accountId: number) {
    return new GenreHistory(
      genre.name,
      genre.subtitle,
      genre.type,
      genre.nsfw,
      genre.shortDescription,
      genre.longDescription,
      genre.notes,
      genre.parents,
      genre.influences,
      genre.akas,
      genre.id,
      genre.createdAt,
      operation,
      accountId,
    )
  }
}

---

File: ./src/lib/server/features/genres/domain/genre-tree.ts
Contents:
import type { Genre } from './genre'

export class GenreTree {
  private map: Map<number, GenreTreeNode>

  constructor(nodes: GenreTreeNode[]) {
    this.map = new Map(nodes.map((node) => [node.id, node]))
  }

  updateGenre(id: number, genre: Genre) {
    this.map.set(id, new GenreTreeNode(id, genre.name, genre.parents))
  }

  findCycle(): string | undefined {
    for (const genre of this.map.values()) {
      const cycle = this.findCycleInner(genre.id, [])
      if (cycle) {
        const formattedCycle = cycle.map((id) => this.map.get(id)!.name).join('  ')
        return formattedCycle
      }
    }
  }

  private findCycleInner(id: number, stack: number[]): number[] | false {
    if (stack.includes(id)) {
      return [...stack, id]
    }

    const genre = this.map.get(id)
    if (!genre) return false

    for (const parentId of genre.parents) {
      const cycle = this.findCycleInner(parentId, [...stack, id])
      if (cycle) {
        return cycle
      }
    }

    return false
  }
}

class GenreTreeNode {
  constructor(
    public id: number,
    public name: string,
    public parents: Set<number>,
  ) {}
}

---

File: ./src/lib/server/features/genres/domain/genre.ts
Contents:
import { equals } from 'ramda'

import type { GenreHistory } from './genre-history'

export type GenreUpdate = {
  name?: string
  subtitle?: string | null
  type?: 'TREND' | 'SCENE' | 'STYLE' | 'META' | 'MOVEMENT'
  nsfw?: boolean
  shortDescription?: string | null
  longDescription?: string | null
  notes?: string | null
  parents?: Set<number>
  influences?: Set<number>
  akas?: {
    primary?: string[]
    secondary?: string[]
    tertiary?: string[]
  }
}

export type GenreConstructorParams = {
  id: number
  name: string
  subtitle?: string
  type: 'TREND' | 'SCENE' | 'STYLE' | 'META' | 'MOVEMENT'
  nsfw: boolean
  shortDescription?: string
  longDescription?: string
  notes?: string
  parents: Set<number>
  influences: Set<number>
  akas: {
    primary: string[]
    secondary: string[]
    tertiary: string[]
  }
  relevance: number
  createdAt: Date
  updatedAt: Date
}

export class Genre {
  readonly id: number
  readonly name: string
  readonly subtitle: string | undefined
  readonly type: 'TREND' | 'SCENE' | 'STYLE' | 'META' | 'MOVEMENT'
  readonly nsfw: boolean
  readonly shortDescription: string | undefined
  readonly longDescription: string | undefined
  readonly notes: string | undefined
  readonly parents: Set<number>
  readonly influences: Set<number>
  readonly akas: {
    readonly primary: string[]
    readonly secondary: string[]
    readonly tertiary: string[]
  }
  readonly relevance: number
  readonly createdAt: Date
  readonly updatedAt: Date

  constructor(params: GenreConstructorParams) {
    this.id = params.id
    this.name = params.name
    this.subtitle = params.subtitle
    this.type = params.type
    this.nsfw = params.nsfw
    this.shortDescription = params.shortDescription
    this.longDescription = params.longDescription
    this.notes = params.notes
    this.parents = new Set(params.parents)
    this.influences = new Set(params.influences)
    this.akas = {
      primary: [...params.akas.primary],
      secondary: [...params.akas.secondary],
      tertiary: [...params.akas.tertiary],
    }
    this.relevance = params.relevance
    this.createdAt = new Date(params.createdAt)
    this.updatedAt = new Date(params.updatedAt)
  }

  withUpdate(data: GenreUpdate): Genre {
    return new Genre({
      id: this.id,
      name: data.name ?? this.name,
      subtitle: data.subtitle === undefined ? this.subtitle : (data.subtitle ?? undefined),
      type: data.type ?? this.type,
      nsfw: data.nsfw ?? this.nsfw,
      shortDescription:
        data.shortDescription === undefined
          ? this.shortDescription
          : (data.shortDescription ?? undefined),
      longDescription:
        data.longDescription === undefined
          ? this.longDescription
          : (data.longDescription ?? undefined),
      notes: data.notes === undefined ? this.notes : (data.notes ?? undefined),
      parents: data.parents ?? this.parents,
      influences: data.influences ?? this.influences,
      akas: {
        primary: data.akas?.primary ?? this.akas.primary,
        secondary: data.akas?.secondary ?? this.akas.secondary,
        tertiary: data.akas?.tertiary ?? this.akas.tertiary,
      },
      relevance: this.relevance,
      createdAt: this.createdAt,
      updatedAt: new Date(),
    })
  }

  hasSelfInfluence(): boolean {
    return this.influences.has(this.id)
  }

  isChangedFrom(genreHistory: GenreHistory): boolean {
    return (
      this.name !== genreHistory.name ||
      this.subtitle !== genreHistory.subtitle ||
      this.type !== genreHistory.type ||
      this.nsfw !== genreHistory.nsfw ||
      this.shortDescription !== genreHistory.shortDescription ||
      this.longDescription !== genreHistory.longDescription ||
      this.notes !== genreHistory.notes ||
      !equals(this.parents, genreHistory.parents) ||
      !equals(this.influences, genreHistory.influences) ||
      !equals(this.akas, genreHistory.akas)
    )
  }
}

---

File: ./src/lib/server/features/genres/infrastructure/genre/drizzle-genre-repository.ts
Contents:
import { eq } from 'drizzle-orm'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import { genreAkas, genreInfluences, genreParents, genres } from '$lib/server/db/schema'

import { Genre } from '../../domain/genre'
import { GenreTree } from '../../domain/genre-tree'
import type { GenreRepository } from './genre-repository'

export class DrizzleGenreRepository implements GenreRepository {
  constructor(private db: IDrizzleConnection) {}

  async findById(id: number): Promise<Genre | undefined> {
    const entry = await this.db.query.genres.findFirst({
      where: (genres, { eq }) => eq(genres.id, id),
      with: {
        parents: { columns: { parentId: true } },
        influencedBy: { columns: { influencerId: true } },
        akas: {
          columns: { name: true, relevance: true },
          orderBy: (genreAkas, { asc, desc }) => [desc(genreAkas.relevance), asc(genreAkas.order)],
        },
      },
    })
    if (!entry) return

    const parents = new Set(entry.parents.map((p) => p.parentId))
    const influences = new Set(entry.influencedBy.map((i) => i.influencerId))

    const akas: { primary: string[]; secondary: string[]; tertiary: string[] } = {
      primary: [],
      secondary: [],
      tertiary: [],
    }
    for (const aka of entry.akas) {
      if (aka.relevance === 3) {
        akas.primary.push(aka.name)
      } else if (aka.relevance === 2) {
        akas.secondary.push(aka.name)
      } else {
        akas.tertiary.push(aka.name)
      }
    }

    const genre = new Genre({
      id: entry.id,
      name: entry.name,
      subtitle: entry.subtitle ?? undefined,
      type: entry.type,
      nsfw: entry.nsfw,
      shortDescription: entry.shortDescription ?? undefined,
      longDescription: entry.longDescription ?? undefined,
      notes: entry.notes ?? undefined,
      parents,
      influences,
      akas,
      relevance: entry.relevance,
      createdAt: entry.createdAt,
      updatedAt: entry.updatedAt,
    })

    return genre
  }

  async getGenreTree(): Promise<GenreTree> {
    const nodes = await this.db.query.genres.findMany({
      columns: {
        id: true,
        name: true,
      },
      with: {
        parents: { columns: { parentId: true } },
      },
    })

    const tree = new GenreTree(
      nodes.map((node) => ({
        id: node.id,
        name: node.name,
        parents: new Set(node.parents.map((p) => p.parentId)),
      })),
    )

    return tree
  }

  async update(id: number, genre: Genre): Promise<void> {
    await this.db.transaction(async (tx) => {
      await tx
        .update(genres)
        .set({
          name: genre.name,
          subtitle: genre.subtitle,
          type: genre.type,
          nsfw: genre.nsfw,
          shortDescription: genre.shortDescription,
          longDescription: genre.longDescription,
          notes: genre.notes,
          relevance: genre.relevance,
          updatedAt: genre.updatedAt,
        })
        .where(eq(genres.id, id))

      await tx.delete(genreAkas).where(eq(genreAkas.genreId, id))
      const akas = [
        ...genre.akas.primary.map((name, order) => ({ genreId: id, name, relevance: 3, order })),
        ...genre.akas.secondary.map((name, order) => ({ genreId: id, name, relevance: 2, order })),
        ...genre.akas.tertiary.map((name, order) => ({ genreId: id, name, relevance: 1, order })),
      ]
      if (akas.length > 0) {
        await tx.insert(genreAkas).values(akas)
      }

      await tx.delete(genreParents).where(eq(genreParents.childId, id))
      if (genre.parents.size > 0) {
        await tx.insert(genreParents).values(
          [...genre.parents].map((parentId) => ({
            parentId,
            childId: id,
          })),
        )
      }

      await tx.delete(genreInfluences).where(eq(genreInfluences.influencedId, id))
      if (genre.influences.size > 0) {
        await tx.insert(genreInfluences).values(
          [...genre.influences].map((influencerId) => ({
            influencerId,
            influencedId: id,
          })),
        )
      }
    })
  }
}

---

File: ./src/lib/server/features/genres/infrastructure/genre/genre-repository.ts
Contents:
import type { Genre } from '../../domain/genre'
import type { GenreTree } from '../../domain/genre-tree'

export type GenreRepository = {
  findById(id: number): Promise<Genre | undefined>
  getGenreTree(): Promise<GenreTree>
  update(id: number, genre: Genre): Promise<void>
}

---

File: ./src/lib/server/features/genres/infrastructure/genre-history/drizzle-genre-history-repository.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { genreHistory, genreHistoryAkas } from '$lib/server/db/schema'

import { GenreHistory } from '../../domain/genre-history'
import type { GenreHistoryRepository } from './genre-history-repository'

export class DrizzleGenreHistoryRepository implements GenreHistoryRepository {
  constructor(private db: IDrizzleConnection) {}

  async findLatestByGenreId(genreId: number): Promise<GenreHistory | undefined> {
    const entry = await this.db.query.genreHistory.findFirst({
      where: (genreHistory, { eq }) => eq(genreHistory.treeGenreId, genreId),
      orderBy: (genreHistory, { desc }) => desc(genreHistory.createdAt),
      with: {
        akas: {
          columns: { name: true, relevance: true },
          orderBy: (genreHistoryAkas, { asc, desc }) => [
            desc(genreHistoryAkas.relevance),
            asc(genreHistoryAkas.order),
          ],
        },
      },
    })
    if (!entry) return

    const akas: { primary: string[]; secondary: string[]; tertiary: string[] } = {
      primary: [],
      secondary: [],
      tertiary: [],
    }
    for (const aka of entry.akas) {
      if (aka.relevance === 3) {
        akas.primary.push(aka.name)
      } else if (aka.relevance === 2) {
        akas.secondary.push(aka.name)
      } else {
        akas.tertiary.push(aka.name)
      }
    }

    const genreHistory = new GenreHistory(
      entry.name,
      entry.subtitle ?? undefined,
      entry.type,
      entry.nsfw,
      entry.shortDescription ?? undefined,
      entry.longDescription ?? undefined,
      entry.notes ?? undefined,

      new Set(entry.parentGenreIds),
      new Set(entry.influencedByGenreIds),
      akas,

      entry.treeGenreId,
      entry.createdAt,
      entry.operation,
      entry.accountId ?? undefined,
    )

    return genreHistory
  }

  async create(history: GenreHistory): Promise<void> {
    await this.db.transaction(async (tx) => {
      const [{ genreHistoryId }] = await tx
        .insert(genreHistory)
        .values({
          name: history.name,
          subtitle: history.subtitle,
          type: history.type,
          nsfw: history.nsfw,
          shortDescription: history.shortDescription,
          longDescription: history.longDescription,
          notes: history.notes,
          parentGenreIds: [...history.parents],
          influencedByGenreIds: [...history.influences],
          treeGenreId: history.genreId,
          createdAt: history.createdAt,
          operation: history.operation,
          accountId: history.accountId,
        })
        .returning({ genreHistoryId: genreHistory.id })

      const akas = [
        ...history.akas.primary.map((name, order) => ({
          genreId: genreHistoryId,
          name,
          relevance: 3,
          order,
        })),
        ...history.akas.secondary.map((name, order) => ({
          genreId: genreHistoryId,
          name,
          relevance: 2,
          order,
        })),
        ...history.akas.tertiary.map((name, order) => ({
          genreId: genreHistoryId,
          name,
          relevance: 1,
          order,
        })),
      ]
      if (akas.length > 0) {
        await tx.insert(genreHistoryAkas).values(akas)
      }
    })
  }
}

---

File: ./src/lib/server/features/genres/infrastructure/genre-history/genre-history-repository.ts
Contents:
import type { GenreHistory } from '../../domain/genre-history'

export type GenreHistoryRepository = {
  findLatestByGenreId(genreId: number): Promise<GenreHistory | undefined>
  create(history: GenreHistory): Promise<void>
}

---

File: ./src/lib/server/features/music-catalog/application/music-catalog-service.ts
Contents:
import { Artist } from '../domain/artist'
import { Release } from '../domain/release'
import { Track } from '../domain/track'
import type { ArtistRepository } from '../infrastructure/artist/artist-repository'
import type { ReleaseRepository } from '../infrastructure/release/release-repository'
import type { TrackRepository } from '../infrastructure/track/track-repository'

export type CreateRelease = {
  title: string
  art?: string
  artists: number[]
  tracks: (number | { title: string; artists: number[] })[]
}

export class MusicCatalogService {
  constructor(
    private artistRepo: ArtistRepository,
    private releaseRepo: ReleaseRepository,
    private trackRepo: TrackRepository,
  ) {}

  async createRelease(input: CreateRelease): Promise<number> {
    const release = new Release(input.title, input.art)

    for (const artist of input.artists) {
      release.addArtist(artist)
    }

    for (const track of input.tracks) {
      if (typeof track === 'number') {
        release.addTrack(track)
      } else {
        const track_ = new Track(track.title)
        for (const artist of track.artists) {
          track_.addArtist(artist)
        }
        const trackId = await this.trackRepo.create(track_)
        release.addTrack(trackId)
      }
    }

    const releaseId = await this.releaseRepo.create(release)

    return releaseId
  }

  async createArtist(name: string): Promise<number> {
    const artist = new Artist(name)

    const artistId = await this.artistRepo.create(artist)

    return artistId
  }
}

---

File: ./src/lib/server/features/music-catalog/domain/artist.ts
Contents:
export class Artist {
  constructor(public name: string) {}
}

---

File: ./src/lib/server/features/music-catalog/domain/release.ts
Contents:
export class Release {
  public artists: number[] = []
  public tracks: number[] = []

  constructor(
    public title: string,
    public art?: string,
  ) {}

  addArtist(artistId: number) {
    this.artists.push(artistId)
  }

  addTrack(trackId: number) {
    this.tracks.push(trackId)
  }
}

---

File: ./src/lib/server/features/music-catalog/domain/track.ts
Contents:
export class Track {
  public artists: number[] = []

  constructor(public title: string) {}

  addArtist(artistId: number) {
    this.artists.push(artistId)
  }
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/artist/artist-repository.ts
Contents:
import type { Artist } from '../../domain/artist'

export type ArtistRepository = {
  create(artist: Artist): Promise<number>
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/artist/drizzle-artist-repository.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { artists } from '$lib/server/db/schema'

import type { Artist } from '../../domain/artist'
import type { ArtistRepository } from './artist-repository'

export class DrizzleArtistRepository implements ArtistRepository {
  constructor(private db: IDrizzleConnection) {}

  async create(artist: Artist): Promise<number> {
    const artistId = await this.db.transaction(async (tx) => {
      const [{ artistId }] = await tx
        .insert(artists)
        .values({
          name: artist.name,
        })
        .returning({ artistId: artists.id })

      return artistId
    })

    return artistId
  }
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/release/drizzle-release-repository.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { releaseArtists, releases, releaseTracks } from '$lib/server/db/schema'

import type { Release } from '../../domain/release'
import type { ReleaseRepository } from './release-repository'

export class DrizzleReleaseRepository implements ReleaseRepository {
  constructor(private db: IDrizzleConnection) {}

  async create(release: Release): Promise<number> {
    const releaseId = await this.db.transaction(async (tx) => {
      const [{ releaseId }] = await tx
        .insert(releases)
        .values({
          title: release.title,
          art: release.art,
        })
        .returning({ releaseId: releases.id })

      await tx.insert(releaseArtists).values(
        release.artists.map((artistId, i) => ({
          releaseId,
          artistId,
          order: i,
        })),
      )

      await tx.insert(releaseTracks).values(
        release.tracks.map((trackId, i) => ({
          releaseId,
          trackId,
          order: i,
        })),
      )

      return releaseId
    })

    return releaseId
  }
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/release/release-repository.ts
Contents:
import type { Release } from '../../domain/release'

export type ReleaseRepository = {
  create(release: Release): Promise<number>
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/track/drizzle-track-repository.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { trackArtists, tracks } from '$lib/server/db/schema'

import type { Track } from '../../domain/track'
import type { TrackRepository } from './track-repository'

export class DrizzleTrackRepository implements TrackRepository {
  constructor(private db: IDrizzleConnection) {}

  async create(track: Track): Promise<number> {
    const trackId = await this.db.transaction(async (tx) => {
      const [{ trackId }] = await tx
        .insert(tracks)
        .values({
          title: track.title,
        })
        .returning({ trackId: tracks.id })

      await tx.insert(trackArtists).values(
        track.artists.map((artistId, i) => ({
          trackId,
          artistId,
          order: i,
        })),
      )

      return trackId
    })

    return trackId
  }
}

---

File: ./src/lib/server/features/music-catalog/infrastructure/track/track-repository.ts
Contents:
import type { Track } from '../../domain/track'

export type TrackRepository = {
  create(track: Track): Promise<number>
}

---

File: ./src/lib/server/api/artists/get-many.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import ArtistsDatabase, {
  type FindArtist,
  type FindInclude,
  type FindManySortField,
  type FindManySortOrder,
} from '$lib/server/db/controllers/artists'

export type GetManyArtistsParams<I extends FindInclude> = {
  skip?: number
  limit?: number
  include?: I[]
  filter?: {
    ids?: number[]
  }
  sort?: {
    field?: FindManySortField
    order?: FindManySortOrder
  }
}

export default async function getManyArtists<I extends FindInclude = never>(
  { skip = 0, limit, include = [], filter = {}, sort = {} }: GetManyArtistsParams<I>,
  dbConnection: IDrizzleConnection,
): Promise<{
  data: FindArtist<I>[]
  pagination: { skip: number; limit: number | undefined; total: number }
}> {
  const artistsDb = new ArtistsDatabase()

  const { results, total } = await artistsDb.findMany(
    { skip, limit, include, filter, sort },
    dbConnection,
  )

  return {
    data: results,
    pagination: { skip, limit, total },
  }
}

---

File: ./src/lib/server/api/genres/create.test.ts
Contents:
import { describe, expect } from 'vitest'

import { AccountsDatabase } from '$lib/server/db/controllers/accounts'
import { GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreHistoryDatabase } from '$lib/server/db/controllers/genre-history'
import { GenreRelevanceVotesDatabase } from '$lib/server/db/controllers/genre-relevance-votes'

import { test } from '../../../../vitest-setup'
import { createGenre } from './create'
import type { GenreData } from './types'

describe('createGenre', () => {
  test('should return the created genre id', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: undefined,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-1',
          password: 'test-1',
        },
      ],
      dbConnection,
    )

    const genreId = await createGenre(genreData, account.id, dbConnection)

    expect(genreId).toBeTypeOf('number')
  })

  test('should insert the genre into the database', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: undefined,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-2',
          password: 'test-2',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genresDb = new GenresDatabase()
    const genre = await genresDb.findByIdEdit(id, dbConnection)
    expect(genre).toEqual({
      id: expect.any(Number) as number,
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      parents: [],
      influencedBy: [],
      relevance: 99,
      nsfw: false,
      akas: [],
      createdAt: expect.any(Date) as Date,
      updatedAt: expect.any(Date) as Date,
    })
  })

  test('should map AKAs correctly', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: 'primary one, primary two',
      secondaryAkas: 'secondary one, secondary two',
      tertiaryAkas: 'tertiary one, tertiary two',
      parents: [],
      influencedBy: [],
      relevance: undefined,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-3',
          password: 'test-3',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genresDb = new GenresDatabase()
    const genre = await genresDb.findByIdEdit(id, dbConnection)
    expect(genre).toEqual({
      id: expect.any(Number) as number,
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      parents: [],
      influencedBy: [],
      relevance: 99,
      nsfw: false,
      akas: [
        { name: 'primary one', relevance: 3, order: 0 },
        { name: 'primary two', relevance: 3, order: 1 },
        { name: 'secondary one', relevance: 2, order: 0 },
        { name: 'secondary two', relevance: 2, order: 1 },
        { name: 'tertiary one', relevance: 1, order: 0 },
        { name: 'tertiary two', relevance: 1, order: 1 },
      ],
      createdAt: expect.any(Date) as Date,
      updatedAt: expect.any(Date) as Date,
    })
  })

  test('should insert a history entry', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: undefined,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-3',
          password: 'test-3',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genreHistoryDb = new GenreHistoryDatabase()
    const genreHistory = await genreHistoryDb.findByGenreId(id, dbConnection)
    expect(genreHistory).toEqual([
      {
        id: expect.any(Number) as number,
        treeGenreId: id,
        name: 'Test',
        subtitle: null,
        type: 'STYLE',
        shortDescription: null,
        longDescription: null,
        notes: null,
        akas: [],
        parentGenreIds: [],
        influencedByGenreIds: [],
        nsfw: false,
        accountId: account.id,
        operation: 'CREATE',
        createdAt: expect.any(Date) as Date,
        account: {
          id: account.id,
          username: 'test-3',
        },
      },
    ])
  })

  test('should insert a relevance vote when relevance is set', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: 1,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-3',
          password: 'test-3',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()
    const genreRelevanceVote = await genreRelevanceVotesDb.findByGenreIdAndAccountId(
      id,
      account.id,
      dbConnection,
    )
    expect(genreRelevanceVote).toEqual({
      genreId: id,
      accountId: account.id,
      relevance: 1,
      createdAt: expect.any(Date) as Date,
      updatedAt: expect.any(Date) as Date,
    })

    const genresDb = new GenresDatabase()
    const genre = await genresDb.findByIdEdit(id, dbConnection)
    expect(genre?.relevance).toBe(1)
  })

  test('should not insert a relevance vote when relevance is undefined', async ({
    dbConnection,
  }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: undefined,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-3',
          password: 'test-3',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()
    const genreRelevanceVote = await genreRelevanceVotesDb.findByGenreIdAndAccountId(
      id,
      account.id,
      dbConnection,
    )
    expect(genreRelevanceVote).toBeUndefined()

    const genresDb = new GenresDatabase()
    const genre = await genresDb.findByIdEdit(id, dbConnection)
    expect(genre?.relevance).toBe(99)
  })

  test('should not insert a relevance vote when relevance is unset', async ({ dbConnection }) => {
    const genreData: GenreData = {
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      shortDescription: null,
      longDescription: null,
      notes: null,
      primaryAkas: null,
      secondaryAkas: null,
      tertiaryAkas: null,
      parents: [],
      influencedBy: [],
      relevance: 99,
      nsfw: false,
    }

    const accountsDb = new AccountsDatabase()
    const [account] = await accountsDb.insert(
      [
        {
          username: 'test-3',
          password: 'test-3',
        },
      ],
      dbConnection,
    )

    const id = await createGenre(genreData, account.id, dbConnection)

    const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()
    const genreRelevanceVote = await genreRelevanceVotesDb.findByGenreIdAndAccountId(
      id,
      account.id,
      dbConnection,
    )
    expect(genreRelevanceVote).toBeUndefined()

    const genresDb = new GenresDatabase()
    const genre = await genresDb.findByIdEdit(id, dbConnection)
    expect(genre?.relevance).toBe(99)
  })
})

---

File: ./src/lib/server/api/genres/create.ts
Contents:
import { omit } from 'ramda'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import { GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreHistoryDatabase } from '$lib/server/db/controllers/genre-history'
import { GenreRelevanceVotesDatabase } from '$lib/server/db/controllers/genre-relevance-votes'
import { UNSET_GENRE_RELEVANCE } from '$lib/types/genres'

import type { Account } from '../../db/schema'
import type { GenreData } from './types'

export async function createGenre(
  data: GenreData,
  accountId: Account['id'],
  dbConnection: IDrizzleConnection,
): Promise<number> {
  const genresDb = new GenresDatabase()
  const genreHistoryDb = new GenreHistoryDatabase()
  const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()

  const genre = await dbConnection.transaction(async (tx) => {
    const [genre] = await genresDb.insert(
      [
        {
          ...data,
          akas: [
            ...(data.primaryAkas ?? '')
              .split(',')
              .map((s) => s.trim())
              .filter((s) => s.length > 0)
              .map((name, order) => ({ name, relevance: 3, order })),
            ...(data.secondaryAkas ?? '')
              .split(',')
              .map((s) => s.trim())
              .filter((s) => s.length > 0)
              .map((name, order) => ({ name, relevance: 2, order })),
            ...(data.tertiaryAkas ?? '')
              .split(',')
              .map((s) => s.trim())
              .filter((s) => s.length > 0)
              .map((name, order) => ({ name, relevance: 1, order })),
          ],
          updatedAt: new Date(),
        },
      ],
      tx,
    )

    await genreHistoryDb.insert(
      [
        {
          ...omit(['id', 'parents', 'influencedBy', 'createdAt', 'updatedAt'], genre),
          treeGenreId: genre.id,
          parentGenreIds: genre.parents,
          influencedByGenreIds: genre.influencedBy,
          operation: 'CREATE',
          accountId,
          akas: genre.akas,
        },
      ],
      tx,
    )

    if (data.relevance !== undefined && data.relevance !== UNSET_GENRE_RELEVANCE) {
      await genreRelevanceVotesDb.upsert(
        {
          genreId: genre.id,
          accountId,
          relevance: data.relevance,
          updatedAt: new Date(),
        },
        tx,
      )
    }

    return genre
  })

  return genre.id
}

---

File: ./src/lib/server/api/genres/delete.test.ts
Contents:
import { expect } from 'vitest'

import { AccountsDatabase } from '$lib/server/db/controllers/accounts'
import { type ExtendedInsertGenre, GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreHistoryDatabase } from '$lib/server/db/controllers/genre-history'
import { NotFoundError } from '$lib/server/features/genres/application/genre-service'

import { test } from '../../../../vitest-setup'
import { deleteGenre } from './delete'

function getTestGenre(data?: Partial<ExtendedInsertGenre>): ExtendedInsertGenre {
  return { name: 'Test', akas: [], parents: [], influencedBy: [], updatedAt: new Date(), ...data }
}

test('should delete the genre', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountId = new AccountsDatabase()
  const [account] = await accountId.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await deleteGenre(genre.id, account.id, dbConnection)

  const genres = await genresDb.findAllIds(dbConnection)
  expect(genres).toHaveLength(0)
})

test('should throw NotFoundError if genre not found', async ({ dbConnection }) => {
  const accountId = new AccountsDatabase()
  const [account] = await accountId.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(deleteGenre(0, account.id, dbConnection)).rejects.toThrow(NotFoundError)
})

test('should create a genre history entry', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountId = new AccountsDatabase()
  const [account] = await accountId.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await deleteGenre(genre.id, account.id, dbConnection)

  const genreHistoryDb = new GenreHistoryDatabase()
  const genreHistory = await genreHistoryDb.findByGenreId(genre.id, dbConnection)
  expect(genreHistory).toEqual([
    {
      account: {
        id: account.id,
        username: 'Test',
      },
      accountId: account.id,
      akas: [],
      createdAt: expect.any(Date) as Date,
      id: 1,
      influencedByGenreIds: [],
      longDescription: null,
      name: 'Test',
      notes: null,
      nsfw: false,
      operation: 'DELETE',
      parentGenreIds: [],
      shortDescription: null,
      subtitle: null,
      treeGenreId: 1,
      type: 'STYLE',
    },
  ])
})

test("should move child genres under deleted genre's parents", async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [, child] = await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent' }),
      getTestGenre({ id: 1, name: 'Child', parents: [0] }),
      getTestGenre({ id: 2, name: 'Grandchild', parents: [1] }),
    ],
    dbConnection,
  )

  const accountId = new AccountsDatabase()
  const [account] = await accountId.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await deleteGenre(child.id, account.id, dbConnection)

  const genres = await genresDb.findAll({ include: ['parents'] }, dbConnection)
  expect(genres.results).toEqual([
    expect.objectContaining({
      id: 0,
      name: 'Parent',
      parents: [],
    }),
    expect.objectContaining({
      id: 2,
      name: 'Grandchild',
      parents: [0],
    }),
  ])
})

test('should create history entries for children that were moved', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [parent, child, grandchild] = await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent' }),
      getTestGenre({ id: 1, name: 'Child', parents: [0] }),
      getTestGenre({ id: 2, name: 'Grandchild', parents: [1] }),
    ],
    dbConnection,
  )

  const accountId = new AccountsDatabase()
  const [account] = await accountId.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await deleteGenre(child.id, account.id, dbConnection)

  const genreHistoryDb = new GenreHistoryDatabase()

  const parentHistory = await genreHistoryDb.findByGenreId(parent.id, dbConnection)
  expect(parentHistory).toEqual([])

  const childHistory = await genreHistoryDb.findByGenreId(child.id, dbConnection)
  expect(childHistory).toEqual([
    {
      account: {
        id: account.id,
        username: 'Test',
      },
      accountId: account.id,
      akas: [],
      createdAt: expect.any(Date) as Date,
      id: 1,
      influencedByGenreIds: [],
      longDescription: null,
      name: 'Child',
      notes: null,
      nsfw: false,
      operation: 'DELETE',
      parentGenreIds: [0],
      shortDescription: null,
      subtitle: null,
      treeGenreId: 1,
      type: 'STYLE',
    },
  ])

  const grandchildHistory = await genreHistoryDb.findByGenreId(grandchild.id, dbConnection)
  expect(grandchildHistory).toEqual([
    {
      account: {
        id: account.id,
        username: 'Test',
      },
      accountId: account.id,
      akas: [],
      createdAt: expect.any(Date) as Date,
      id: 2,
      influencedByGenreIds: [],
      longDescription: null,
      name: 'Grandchild',
      notes: null,
      nsfw: false,
      operation: 'UPDATE',
      parentGenreIds: [0],
      shortDescription: null,
      subtitle: null,
      treeGenreId: 2,
      type: 'STYLE',
    },
  ])
})

---

File: ./src/lib/server/api/genres/delete.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreParentsDatabase } from '$lib/server/db/controllers/genre-parents'
import { NotFoundError } from '$lib/server/features/genres/application/genre-service'
import { createGenreHistoryEntry } from '$lib/server/genres'

import type { Account, Genre } from '../../db/schema'

export async function deleteGenre(
  id: Genre['id'],
  accountId: Account['id'],
  dbConnection: IDrizzleConnection,
): Promise<void> {
  const genresDb = new GenresDatabase()
  const genreParentsDb = new GenreParentsDatabase()

  await dbConnection.transaction(async (tx) => {
    const genre = await genresDb.findByIdHistory(id, tx)
    if (!genre) {
      throw new NotFoundError()
    }

    // move child genres under deleted genre's parents
    await Promise.all(
      genre.children.flatMap((childId) =>
        genre.parents.map((parentId) => genreParentsDb.update(id, childId, { parentId }, tx)),
      ),
    )

    await genresDb.deleteById(id, tx)

    await createGenreHistoryEntry({
      genre,
      accountId,
      operation: 'DELETE',
      connection: tx,
    })

    const children = await genresDb.findByIds(genre.children, tx)
    await Promise.all(
      children.map((genre) =>
        createGenreHistoryEntry({
          genre,
          accountId,
          operation: 'UPDATE',
          connection: tx,
        }),
      ),
    )
  })
}

---

File: ./src/lib/server/api/genres/get-many.test.ts
Contents:
import { expect } from 'vitest'

import { AccountsDatabase } from '$lib/server/db/controllers/accounts'
import { type ExtendedInsertGenre, GenresDatabase } from '$lib/server/db/controllers/genre'
import { createGenreHistoryEntry } from '$lib/server/genres'
import { UNSET_GENRE_RELEVANCE } from '$lib/types/genres'

import { test } from '../../../../vitest-setup'
import getManyGenres from './get-many'

function getTestGenre(data?: Partial<ExtendedInsertGenre>): ExtendedInsertGenre {
  return { name: 'Test', akas: [], parents: [], influencedBy: [], updatedAt: new Date(), ...data }
}

test('should have a default limit', async ({ dbConnection }) => {
  const result = await getManyGenres({}, dbConnection)
  expect(result.pagination.limit).toBe(25)
})

test('should return an empty array of genres when there are no genres in the DB', async ({
  dbConnection,
}) => {
  const result = await getManyGenres({}, dbConnection)
  expect(result.data).toEqual([])
  expect(result.pagination.total).toBe(0)
})

test('should return an array of genres when there are genres in the DB', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert([getTestGenre()], dbConnection)

  const result = await getManyGenres({}, dbConnection)
  expect(result.data).toEqual([
    {
      id: 1,
      name: 'Test',
      subtitle: null,
      type: 'STYLE',
      nsfw: false,
      shortDescription: null,
      longDescription: null,
      notes: null,
      relevance: 99,
      createdAt: expect.any(Date) as Date,
      updatedAt: expect.any(Date) as Date,
    },
  ])
  expect(result.pagination.total).toEqual(1)
})

test('should paginate the results', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1' }),
      getTestGenre({ name: 'Test 2' }),
      getTestGenre({ name: 'Test 3' }),
      getTestGenre({ name: 'Test 4' }),
      getTestGenre({ name: 'Test 5' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ skip: 2, limit: 2 }, dbConnection)

  expect(result).toEqual({
    data: [
      expect.objectContaining({ name: 'Test 3' }),
      expect.objectContaining({ name: 'Test 4' }),
    ],
    pagination: {
      skip: 2,
      limit: 2,
      total: 5,
    },
  })
})

test('should handle a limit that is larger than the number of genres in the DB', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert([getTestGenre({ name: 'Test' })], dbConnection)

  const result = await getManyGenres({ limit: 10 }, dbConnection)

  expect(result).toEqual({
    data: [expect.objectContaining({ name: 'Test' })],
    pagination: {
      skip: 0,
      limit: 10,
      total: 1,
    },
  })
})

test('should handle a skip that is larger than the number of genres in the DB', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert([getTestGenre()], dbConnection)

  const result = await getManyGenres({ skip: 10 }, dbConnection)

  expect(result).toEqual({
    data: [],
    pagination: {
      skip: 10,
      limit: expect.any(Number) as number,
      total: 1,
    },
  })
})

test('should handle a limit of 0', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert([getTestGenre()], dbConnection)

  const result = await getManyGenres({ limit: 0 }, dbConnection)

  expect(result).toEqual({
    data: [],
    pagination: {
      skip: 0,
      limit: 0,
      total: 1,
    },
  })
})

test('should include parent ids when requested', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'Test 1', parents: [2] }), getTestGenre({ name: 'Test 2', parents: [] })],
    dbConnection,
  )

  const result = await getManyGenres({ include: ['parents'] }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({
      name: 'Test 1',
      parents: [2],
    }),
    expect.objectContaining({
      name: 'Test 2',
      parents: [],
    }),
  ])
})

test('should include influencedBy ids when requested', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', influencedBy: [2] }),
      getTestGenre({ name: 'Test 2', influencedBy: [] }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ include: ['influencedBy'] }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({
      name: 'Test 1',
      influencedBy: [2],
    }),
    expect.objectContaining({
      name: 'Test 2',
      influencedBy: [],
    }),
  ])
})

test('should include akas when requested', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({
        name: 'Test 1',
        akas: [
          { relevance: 1, order: 1, name: 'tertiary-two' },
          { relevance: 1, order: 0, name: 'tertiary-one' },
          { relevance: 2, order: 1, name: 'secondary-two' },
          { relevance: 2, order: 0, name: 'secondary-one' },
          { relevance: 3, order: 0, name: 'primary-one' },
          { relevance: 3, order: 1, name: 'primary-two' },
        ],
      }),
      getTestGenre({
        name: 'Test 2',
        influencedBy: [],
      }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ include: ['akas'] }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({
      name: 'Test 1',
      akas: {
        primary: ['primary-one', 'primary-two'],
        secondary: ['secondary-one', 'secondary-two'],
        tertiary: ['tertiary-one', 'tertiary-two'],
      },
    }),
    expect.objectContaining({
      name: 'Test 2',
      akas: {
        primary: [],
        secondary: [],
        tertiary: [],
      },
    }),
  ])
})

test('should allow filtering on name by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'Test 1' }), getTestGenre({ name: 'Test 2' })],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { name: 'Test 2' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 2' })])
})

test('should allow filtering on subtitle by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', subtitle: '' }),
      getTestGenre({ name: 'Test 2', subtitle: null }),
      getTestGenre({ name: 'Test 3', subtitle: undefined }),
      getTestGenre({ name: 'Test 4', subtitle: 'Test Subtitle' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { subtitle: 'Test Subtitle' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 4' })])
})

test('should allow filtering on subtitle by empty string', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', subtitle: '' }),
      getTestGenre({ name: 'Test 2', subtitle: null }),
      getTestGenre({ name: 'Test 3', subtitle: undefined }),
      getTestGenre({ name: 'Test 4', subtitle: 'Test Subtitle' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { subtitle: '' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on subtitle by null', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', subtitle: '' }),
      getTestGenre({ name: 'Test 2', subtitle: null }),
      getTestGenre({ name: 'Test 3', subtitle: undefined }),
      getTestGenre({ name: 'Test 4', subtitle: 'Test Subtitle' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { subtitle: null } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on type by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', type: 'STYLE' }),
      getTestGenre({ name: 'Test 2', type: 'META' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { type: 'META' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 2' })])
})

test('should allow filtering on relevance by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', relevance: 1 }),
      getTestGenre({ name: 'Test 2', relevance: 2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { relevance: 2 } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 2' })])
})

test('should allow filtering on relevance by unset value', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', relevance: 1 }),
      getTestGenre({ name: 'Test 2', relevance: UNSET_GENRE_RELEVANCE }),
      getTestGenre({ name: 'Test 3', relevance: undefined }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { relevance: UNSET_GENRE_RELEVANCE } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on relevance by null', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', relevance: 1 }),
      getTestGenre({ name: 'Test 2', relevance: UNSET_GENRE_RELEVANCE }),
      getTestGenre({ name: 'Test 3', relevance: undefined }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { relevance: null } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on NSFW by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'Test 1', nsfw: true }), getTestGenre({ name: 'Test 2', nsfw: false })],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { nsfw: false } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 2' })])
})

test('should allow filtering on shortDescription by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', shortDescription: '' }),
      getTestGenre({ name: 'Test 2', shortDescription: null }),
      getTestGenre({ name: 'Test 3', shortDescription: undefined }),
      getTestGenre({ name: 'Test 4', shortDescription: 'Short' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { shortDescription: 'Short' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 4' })])
})

test('should allow filtering on shortDescription by empty string', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', shortDescription: '' }),
      getTestGenre({ name: 'Test 2', shortDescription: null }),
      getTestGenre({ name: 'Test 3', shortDescription: undefined }),
      getTestGenre({ name: 'Test 4', shortDescription: 'Short' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { shortDescription: '' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on shortDescription by null', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', shortDescription: '' }),
      getTestGenre({ name: 'Test 2', shortDescription: null }),
      getTestGenre({ name: 'Test 3', shortDescription: undefined }),
      getTestGenre({ name: 'Test 4', shortDescription: 'Short' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { shortDescription: null } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on longDescription by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', longDescription: '' }),
      getTestGenre({ name: 'Test 2', longDescription: null }),
      getTestGenre({ name: 'Test 3', longDescription: undefined }),
      getTestGenre({ name: 'Test 4', longDescription: 'Long' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { longDescription: 'Long' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 4' })])
})

test('should allow filtering on longDescription by empty string', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', longDescription: '' }),
      getTestGenre({ name: 'Test 2', longDescription: null }),
      getTestGenre({ name: 'Test 3', longDescription: undefined }),
      getTestGenre({ name: 'Test 4', longDescription: 'Long' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { longDescription: '' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on longDescription by null', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', longDescription: '' }),
      getTestGenre({ name: 'Test 2', longDescription: null }),
      getTestGenre({ name: 'Test 3', longDescription: undefined }),
      getTestGenre({ name: 'Test 4', longDescription: 'Long' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { longDescription: null } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on notes by exact match', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', notes: '' }),
      getTestGenre({ name: 'Test 2', notes: null }),
      getTestGenre({ name: 'Test 3', notes: undefined }),
      getTestGenre({ name: 'Test 4', notes: 'Notes' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { notes: 'Notes' } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 4' })])
})

test('should allow filtering on notes by empty string', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', notes: '' }),
      getTestGenre({ name: 'Test 2', notes: null }),
      getTestGenre({ name: 'Test 3', notes: undefined }),
      getTestGenre({ name: 'Test 4', notes: 'Notes' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { notes: '' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on notes by null', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', notes: '' }),
      getTestGenre({ name: 'Test 2', notes: null }),
      getTestGenre({ name: 'Test 3', notes: undefined }),
      getTestGenre({ name: 'Test 4', notes: 'Notes' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { notes: null } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Test 1' }),
    expect.objectContaining({ name: 'Test 2' }),
    expect.objectContaining({ name: 'Test 3' }),
  ])
})

test('should allow filtering on createdAt by exact match', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', createdAt: date1 }),
      getTestGenre({ name: 'Test 2', createdAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { createdAt: date1 } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 1' })])
})

test('should allow filtering on updatedAt by exact match', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'Test 1', updatedAt: date1 }),
      getTestGenre({ name: 'Test 2', updatedAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { updatedAt: date1 } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 1' })])
})

test('should allow filtering by createdBy', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre1, genre2] = await genresDb.insert(
    [getTestGenre({ name: 'Test 1' }), getTestGenre({ name: 'Test 2' })],
    dbConnection,
  )

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert(
    [{ username: 'Testing', password: 'Pass' }],
    dbConnection,
  )

  await createGenreHistoryEntry({
    genre: genre1,
    accountId: account.id,
    operation: 'CREATE',
    connection: dbConnection,
  })
  await createGenreHistoryEntry({
    genre: genre2,
    accountId: account.id,
    operation: 'UPDATE',
    connection: dbConnection,
  })

  const result = await getManyGenres({ filter: { createdBy: account.id } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 1' })])
})

test('should allow filtering by both createdBy and name', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const genres = await genresDb.insert(
    [getTestGenre({ name: 'Test 1' }), getTestGenre({ name: 'Test 2' })],
    dbConnection,
  )

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert(
    [{ username: 'Testing', password: 'Pass' }],
    dbConnection,
  )

  await Promise.all(
    genres.map((genre) =>
      createGenreHistoryEntry({
        genre,
        accountId: account.id,
        operation: 'CREATE',
        connection: dbConnection,
      }),
    ),
  )

  const result = await getManyGenres(
    { filter: { name: 'Test 1', createdBy: account.id } },
    dbConnection,
  )

  expect(result.data).toEqual([expect.objectContaining({ name: 'Test 1' })])
})

test('should allow filtering by parent id', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ id: 0, name: 'Parent' }), getTestGenre({ id: 1, name: 'Child', parents: [0] })],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { parents: [0] } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Child' })])
})

test('should allow filtering by multiple parent ids', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent 1' }),
      getTestGenre({ id: 1, name: 'Parent 2' }),
      getTestGenre({ id: 2, name: 'Child 1' }),
      getTestGenre({ id: 3, name: 'Child 2', parents: [0] }),
      getTestGenre({ id: 4, name: 'Child 3', parents: [1] }),
      getTestGenre({ id: 5, name: 'Child 4', parents: [0, 1] }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { parents: [0, 1] } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Child 4' })])
})

test('should allow filtering by parents and createdBy', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const genres = await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent 1' }),
      getTestGenre({ id: 1, name: 'Parent 2' }),
      getTestGenre({ id: 2, name: 'Child 1' }),
      getTestGenre({ id: 3, name: 'Child 2', parents: [0] }),
      getTestGenre({ id: 4, name: 'Child 3', parents: [1] }),
      getTestGenre({ id: 5, name: 'Child 4', parents: [0, 1] }),
      getTestGenre({ id: 6, name: 'Child 5', parents: [0] }),
      getTestGenre({ id: 7, name: 'Child 6', parents: [1] }),
      getTestGenre({ id: 8, name: 'Child 7', parents: [0, 1] }),
    ],
    dbConnection,
  )

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert(
    [{ username: 'Testing', password: 'Pass' }],
    dbConnection,
  )

  await Promise.all(
    genres.slice(genres.findIndex((genre) => genre.name === 'Child 5')).map((genre) =>
      createGenreHistoryEntry({
        genre,
        accountId: account.id,
        operation: 'CREATE',
        connection: dbConnection,
      }),
    ),
  )

  const result = await getManyGenres(
    { filter: { parents: [0, 1], createdBy: account.id } },
    dbConnection,
  )

  expect(result.data).toEqual([expect.objectContaining({ name: 'Child 7' })])
})

test('should return no results when filtering by parents and createdBy with no matches', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent 1' }),
      getTestGenre({ id: 1, name: 'Parent 2' }),
      getTestGenre({ id: 2, name: 'Child 1' }),
      getTestGenre({ id: 3, name: 'Child 2', parents: [0] }),
      getTestGenre({ id: 4, name: 'Child 3', parents: [1] }),
      getTestGenre({ id: 5, name: 'Child 4', parents: [0, 1] }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { parents: [0, 1], createdBy: 1 } }, dbConnection)

  expect(result.data).toEqual([])
})

test('should allow filtering by ancestor id', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Grandparent' }),
      getTestGenre({ id: 1, name: 'Parent', parents: [0] }),
      getTestGenre({ id: 2, name: 'Child', parents: [1] }),
      getTestGenre({ id: 3, name: 'Grandchild', parents: [2] }),
      getTestGenre({ id: 4, name: 'Other 1' }),
      getTestGenre({ id: 5, name: 'Other 2', parents: [4] }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { ancestors: [0] } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'Parent' }),
    expect.objectContaining({ name: 'Child' }),
    expect.objectContaining({ name: 'Grandchild' }),
  ])
})

test('should allow filtering by multiple ancestor ids', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Grandparent 1' }),
      getTestGenre({ id: 1, name: 'Parent 1', parents: [0] }),
      getTestGenre({ id: 2, name: 'Child 1', parents: [1] }),
      getTestGenre({ id: 3, name: 'Grandparent 2' }),
      getTestGenre({ id: 4, name: 'Parent 2', parents: [3] }),
      getTestGenre({ id: 5, name: 'Child 2', parents: [4] }),
      getTestGenre({ id: 6, name: 'Grandchild', parents: [2, 5] }),
      getTestGenre({ id: 7, name: 'Other 1' }),
      getTestGenre({ id: 8, name: 'Other 2', parents: [2] }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ filter: { ancestors: [0, 4] } }, dbConnection)

  expect(result.data).toEqual([expect.objectContaining({ name: 'Grandchild' })])
})

test('should allow sorting by id', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 2, name: 'A' }),
      getTestGenre({ id: 0, name: 'B' }),
      getTestGenre({ id: 1, name: 'C' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'id' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by id in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 2, name: 'A' }),
      getTestGenre({ id: 0, name: 'B' }),
      getTestGenre({ id: 1, name: 'C' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'id', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by id in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 2, name: 'A' }),
      getTestGenre({ id: 0, name: 'B' }),
      getTestGenre({ id: 1, name: 'C' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'id', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should sort by id by default', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ id: 2, name: 'A' }),
      getTestGenre({ id: 0, name: 'B' }),
      getTestGenre({ id: 1, name: 'C' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({}, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by name', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'C' }), getTestGenre({ name: 'A' }), getTestGenre({ name: 'B' })],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'name' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by name in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'C' }), getTestGenre({ name: 'A' }), getTestGenre({ name: 'B' })],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'name', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by name in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [getTestGenre({ name: 'C' }), getTestGenre({ name: 'A' }), getTestGenre({ name: 'B' })],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'name', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by subtitle', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', subtitle: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', subtitle: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'subtitle' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by subtitle in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', subtitle: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', subtitle: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'subtitle', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by subtitle in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', subtitle: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', subtitle: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'subtitle', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by type', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', type: 'META' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', type: 'SCENE' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'type' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by type in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', type: 'META' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', type: 'SCENE' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'type', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by type in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', type: 'META' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', type: 'SCENE' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'type', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by relevance', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', relevance: 2 }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', relevance: 1 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'relevance' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by relevance in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', relevance: 2 }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', relevance: 1 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'relevance', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by relevance in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', relevance: 2 }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', relevance: 1 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'relevance', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by NSFW', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', nsfw: true }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', nsfw: false }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'nsfw' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by NSFW in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', nsfw: true }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', nsfw: false }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'nsfw', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by NSFW in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', nsfw: true }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', nsfw: false }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'nsfw', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by shortDescription', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', shortDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', shortDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'shortDescription' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by shortDescription in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', shortDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', shortDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres(
    { sort: { field: 'shortDescription', order: 'asc' } },
    dbConnection,
  )

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by shortDescription in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', shortDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', shortDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres(
    { sort: { field: 'shortDescription', order: 'desc' } },
    dbConnection,
  )

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by longDescription', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', longDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', longDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'longDescription' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by longDescription in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', longDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', longDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres(
    { sort: { field: 'longDescription', order: 'asc' } },
    dbConnection,
  )

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by longDescription in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', longDescription: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', longDescription: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres(
    { sort: { field: 'longDescription', order: 'desc' } },
    dbConnection,
  )

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by notes', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', notes: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', notes: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'notes' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by notes in ascending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', notes: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', notes: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'notes', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by notes in descending order', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', notes: 'B' }),
      getTestGenre({ name: 'A' }),
      getTestGenre({ name: 'B', notes: 'A' }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'notes', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
  ])
})

test('should allow sorting by createdAt', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', createdAt: date3 }),
      getTestGenre({ name: 'A', createdAt: date1 }),
      getTestGenre({ name: 'B', createdAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'createdAt' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by createdAt in ascending order', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', createdAt: date3 }),
      getTestGenre({ name: 'A', createdAt: date1 }),
      getTestGenre({ name: 'B', createdAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'createdAt', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by createdAt in descending order', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', createdAt: date3 }),
      getTestGenre({ name: 'A', createdAt: date1 }),
      getTestGenre({ name: 'B', createdAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'createdAt', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

test('should allow sorting by updatedAt', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', updatedAt: date3 }),
      getTestGenre({ name: 'A', updatedAt: date1 }),
      getTestGenre({ name: 'B', updatedAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'updatedAt' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by updatedAt in ascending order', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', updatedAt: date3 }),
      getTestGenre({ name: 'A', updatedAt: date1 }),
      getTestGenre({ name: 'B', updatedAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'updatedAt', order: 'asc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'A' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'C' }),
  ])
})

test('should allow sorting by updatedAt in descending order', async ({ dbConnection }) => {
  const date1 = new Date()
  const date2 = new Date(date1.getTime() + 1000)
  const date3 = new Date(date2.getTime() + 1000)

  const genresDb = new GenresDatabase()
  await genresDb.insert(
    [
      getTestGenre({ name: 'C', updatedAt: date3 }),
      getTestGenre({ name: 'A', updatedAt: date1 }),
      getTestGenre({ name: 'B', updatedAt: date2 }),
    ],
    dbConnection,
  )

  const result = await getManyGenres({ sort: { field: 'updatedAt', order: 'desc' } }, dbConnection)

  expect(result.data).toEqual([
    expect.objectContaining({ name: 'C' }),
    expect.objectContaining({ name: 'B' }),
    expect.objectContaining({ name: 'A' }),
  ])
})

---

File: ./src/lib/server/api/genres/get-many.ts
Contents:
import { intersection } from 'ramda'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import {
  type FindAllGenre,
  type FindAllInclude,
  type FindAllParams,
  type FindAllSortField,
  type FindAllSortOrder,
  GenresDatabase,
} from '$lib/server/db/controllers/genre'
import { GenreHistoryDatabase } from '$lib/server/db/controllers/genre-history'
import { GenreParentsDatabase } from '$lib/server/db/controllers/genre-parents'
import type { GenreType } from '$lib/types/genres'

export type GetManyGenresParams<I extends FindAllInclude> = {
  skip?: number
  limit?: number
  include?: I[]
  filter?: {
    name?: string
    subtitle?: string | null
    type?: GenreType
    relevance?: number | null
    nsfw?: boolean
    shortDescription?: string | null
    longDescription?: string | null
    notes?: string | null
    createdAt?: Date
    updatedAt?: Date
    createdBy?: number
    parents?: number[]
    ancestors?: number[]
  }
  sort?: {
    field?: FindAllSortField
    order?: FindAllSortOrder
  }
}

export default async function getManyGenres<I extends FindAllInclude = never>(
  { skip = 0, limit = 25, include = [], filter = {}, sort = {} }: GetManyGenresParams<I>,
  dbConnection: IDrizzleConnection,
): Promise<{
  data: FindAllGenre<I>[]
  pagination: { skip: number; limit: number; total: number }
}> {
  const genresDb = new GenresDatabase()

  const filter_: FindAllParams<I>['filter'] = filter

  if (filter.createdBy !== undefined) {
    const ids = await getCreatedByFilterGenreIds(filter.createdBy, dbConnection)
    filter_.ids = ids
  }

  if (filter.parents !== undefined) {
    const ids = await getParentsFilterGenreIds(filter.parents, dbConnection)
    if (filter_.ids !== undefined) {
      filter_.ids = intersection(filter_.ids, ids)
    } else {
      filter_.ids = ids
    }
  }

  if (filter.ancestors !== undefined) {
    const ids = await getAncestorsFilterGenreIds(filter.ancestors, dbConnection)
    if (filter_.ids !== undefined) {
      filter_.ids = intersection(filter_.ids, ids)
    } else {
      filter_.ids = ids
    }
  }

  const { results, total } = await genresDb.findAll(
    { skip, limit, include, filter: filter_, sort },
    dbConnection,
  )

  return {
    data: results,
    pagination: { skip, limit, total },
  }
}

async function getCreatedByFilterGenreIds(
  accountId: number,
  dbConnection: IDrizzleConnection,
): Promise<number[]> {
  const genreHistoryDb = new GenreHistoryDatabase()
  const { results: history } = await genreHistoryDb.findAll(
    { filter: { accountId, operation: 'CREATE' } },
    dbConnection,
  )
  return history.map((h) => h.treeGenreId)
}

async function getParentsFilterGenreIds(
  parents: number[],
  dbConnection: IDrizzleConnection,
): Promise<number[]> {
  const genreParentsDb = new GenreParentsDatabase()
  const allParentChildren = await Promise.all(
    parents.map((parentId) => genreParentsDb.findByParentId(parentId, dbConnection)),
  )
  const childIds = allParentChildren
    .map((parentChildren) => parentChildren.map((child) => child.childId))
    .reduce((acc, val) => intersection(acc, val))
  return childIds
}

// Run a depth-first search starting from each ancestor to find all descendants.
// Then take the intersection of all descendants to get the common descendants.
async function getAncestorsFilterGenreIds(
  ancestors: number[],
  dbConnection: IDrizzleConnection,
): Promise<number[]> {
  const genreParentsDb = new GenreParentsDatabase()
  const allParentChildren = await genreParentsDb.findAll(dbConnection)
  const parentsMap = allParentChildren.reduce(
    (acc, val) => {
      acc[val.parentId] = acc[val.parentId] ?? []
      acc[val.parentId].push(val.childId)
      return acc
    },
    {} as Record<number, number[]>,
  )

  const descendantLists = ancestors.map((ancestor) => dfs(ancestor, parentsMap))
  const descendantIds = descendantLists.reduce((acc, val) => intersection(acc, val))
  return descendantIds
}

function dfs(ancestor: number, parentsMap: Record<number, number[]>): number[] {
  const queue: number[] = [ancestor]
  const descendants: number[] = []

  let currentNode = queue.shift()
  while (currentNode !== undefined) {
    const children = parentsMap[currentNode] ?? []
    descendants.push(...children)
    queue.push(...children)
    currentNode = queue.shift()
  }

  return descendants
}

---

File: ./src/lib/server/api/genres/relevance/vote.test.ts
Contents:
import { expect } from 'vitest'

import { AccountsDatabase } from '$lib/server/db/controllers/accounts'
import { type ExtendedInsertGenre, GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreRelevanceVotesDatabase } from '$lib/server/db/controllers/genre-relevance-votes'
import { UNSET_GENRE_RELEVANCE } from '$lib/types/genres'

import { test } from '../../../../../vitest-setup'
import { setRelevanceVote } from './vote'

function getTestGenre(data?: Partial<ExtendedInsertGenre>): ExtendedInsertGenre {
  return { name: 'Test', akas: [], parents: [], influencedBy: [], updatedAt: new Date(), ...data }
}

test('should delete vote and update relevance when relevance is UNSET_GENRE_RELEVANCE', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre({ relevance: 1 })], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  const relevanceVotesDb = new GenreRelevanceVotesDatabase()
  await relevanceVotesDb.upsert(
    { genreId: genre.id, accountId: account.id, relevance: 1, updatedAt: new Date() },
    dbConnection,
  )

  await setRelevanceVote(genre.id, UNSET_GENRE_RELEVANCE, account.id, dbConnection)

  const relevanceVotes = await relevanceVotesDb.findByGenreId(genre.id, dbConnection)
  expect(relevanceVotes).toHaveLength(0)

  const updatedGenre = await genresDb.findByIdSimple(genre.id, dbConnection)
  expect(updatedGenre?.relevance).toBe(UNSET_GENRE_RELEVANCE)
})

test('should upsert vote and update relevance when relevance is not UNSET_GENRE_RELEVANCE', async ({
  dbConnection,
}) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre({ relevance: 1 })], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  const relevanceVotesDb = new GenreRelevanceVotesDatabase()
  await relevanceVotesDb.upsert(
    { genreId: genre.id, accountId: account.id, relevance: 1, updatedAt: new Date() },
    dbConnection,
  )

  await setRelevanceVote(genre.id, 2, account.id, dbConnection)

  const relevanceVotes = await relevanceVotesDb.findByGenreId(genre.id, dbConnection)
  expect(relevanceVotes).toEqual([
    expect.objectContaining({ genreId: genre.id, accountId: account.id, relevance: 2 }),
  ])

  const updatedGenre = await genresDb.findByIdSimple(genre.id, dbConnection)
  expect(updatedGenre?.relevance).toBe(2)
})

test('should calculate median relevance correctly', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const accounts = await accountsDb.insert(
    [
      { username: 'user-1', password: 'user-1' },
      { username: 'user-2', password: 'user-2' },
      { username: 'user-3', password: 'user-3' },
      { username: 'user-4', password: 'user-4' },
      { username: 'user-5', password: 'user-5' },
    ],
    dbConnection,
  )

  await setRelevanceVote(genre.id, 1, accounts[0].id, dbConnection)
  await setRelevanceVote(genre.id, 2, accounts[1].id, dbConnection)
  await setRelevanceVote(genre.id, 3, accounts[2].id, dbConnection)
  await setRelevanceVote(genre.id, 4, accounts[3].id, dbConnection)
  await setRelevanceVote(genre.id, 5, accounts[4].id, dbConnection)

  const updatedGenre = await genresDb.findByIdSimple(genre.id, dbConnection)
  expect(updatedGenre?.relevance).toBe(3)
})

test('should round median relevance to nearest integer', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const accounts = await accountsDb.insert(
    [
      { username: 'user-1', password: 'user-1' },
      { username: 'user-2', password: 'user-2' },
      { username: 'user-3', password: 'user-3' },
      { username: 'user-4', password: 'user-4' },
    ],
    dbConnection,
  )

  await setRelevanceVote(genre.id, 1, accounts[0].id, dbConnection)
  await setRelevanceVote(genre.id, 2, accounts[1].id, dbConnection)
  await setRelevanceVote(genre.id, 3, accounts[2].id, dbConnection)
  await setRelevanceVote(genre.id, 4, accounts[3].id, dbConnection)

  const updatedGenre = await genresDb.findByIdSimple(genre.id, dbConnection)
  expect(updatedGenre?.relevance).toBe(3)
})

---

File: ./src/lib/server/api/genres/relevance/vote.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreRelevanceVotesDatabase } from '$lib/server/db/controllers/genre-relevance-votes'
import { UNSET_GENRE_RELEVANCE } from '$lib/types/genres'
import { median } from '$lib/utils/math'

export async function setRelevanceVote(
  id: number,
  relevance: number,
  accountId: number,
  dbConnection: IDrizzleConnection,
): Promise<void> {
  const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()

  await dbConnection.transaction(async (tx) => {
    if (relevance === UNSET_GENRE_RELEVANCE) {
      await genreRelevanceVotesDb.deleteByGenreId(id, tx)
      await updateRelevance(id, tx)
      return
    }

    await genreRelevanceVotesDb.upsert(
      {
        genreId: id,
        accountId,
        relevance,
        updatedAt: new Date(),
      },
      tx,
    )

    await updateRelevance(id, tx)
  })
}

async function updateRelevance(genreId: number, dbConnection: IDrizzleConnection): Promise<void> {
  const genresDb = new GenresDatabase()
  const genreRelevanceVotesDb = new GenreRelevanceVotesDatabase()

  const votes = await genreRelevanceVotesDb.findByGenreId(genreId, dbConnection)

  const relevance =
    votes.length === 0
      ? UNSET_GENRE_RELEVANCE
      : Math.round(median(votes.map((vote) => vote.relevance)))

  await genresDb.update(genreId, { relevance }, dbConnection)
}

---

File: ./src/lib/server/api/genres/types.ts
Contents:
import { z } from 'zod'

import { GENRE_TYPES, genreRelevance } from '$lib/types/genres'
import { nullableString } from '$lib/utils/validators'

export const genreSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  shortDescription: nullableString,
  longDescription: nullableString,
  notes: nullableString,
  type: z.enum(GENRE_TYPES),
  subtitle: nullableString,

  primaryAkas: nullableString,
  secondaryAkas: nullableString,
  tertiaryAkas: nullableString,

  parents: z.number().int().array(),
  influencedBy: z.number().int().array(),

  relevance: genreRelevance.optional(),
  nsfw: z.boolean(),
})

export type GenreSchema = typeof genreSchema
export type GenreData = z.infer<typeof genreSchema>

---

File: ./src/lib/server/api/genres/update.test.ts
Contents:
import { expect } from 'vitest'

import { AccountsDatabase } from '$lib/server/db/controllers/accounts'
import { type ExtendedInsertGenre, GenresDatabase } from '$lib/server/db/controllers/genre'
import { GenreHistoryDatabase } from '$lib/server/db/controllers/genre-history'
import {
  GenreCycleError,
  NotFoundError,
  NoUpdatesError,
  SelfInfluenceError,
} from '$lib/server/features/genres/application/genre-service'
import { createGenreHistoryEntry } from '$lib/server/genres'

import { test } from '../../../../vitest-setup'
import { type GenreData } from './types'
import { updateGenre } from './update'

function getTestGenre(data?: Partial<ExtendedInsertGenre>): ExtendedInsertGenre {
  return { name: 'Test', akas: [], parents: [], influencedBy: [], updatedAt: new Date(), ...data }
}

const GENRE_UPDATE: GenreData = Object.freeze({
  name: 'Updated Genre',
  shortDescription: 'Updated short desc',
  longDescription: 'Updated long desc',
  notes: 'Updated notes',
  type: 'META',
  subtitle: 'Updated subtitle',
  nsfw: true,
  parents: [3, 4],
  influencedBy: [5, 6],
  relevance: 99,
  primaryAkas: '',
  secondaryAkas: '',
  tertiaryAkas: '',
})

test('should update the genre', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await updateGenre(
    genre.id,
    {
      ...genre,
      name: 'Updated Genre',
      primaryAkas: 'primary-one, primary-two',
      secondaryAkas: 'secondary-one, secondary-two',
      tertiaryAkas: 'tertiary-one, tertiary-two',
    },
    account.id,
    dbConnection,
  )

  const {
    results: [updatedGenre],
  } = await genresDb.findAll({ filter: { ids: [genre.id] }, include: ['akas'] }, dbConnection)
  expect(updatedGenre).toEqual(
    expect.objectContaining({
      id: genre.id,
      name: 'Updated Genre',
      akas: {
        primary: ['primary-one', 'primary-two'],
        secondary: ['secondary-one', 'secondary-two'],
        tertiary: ['tertiary-one', 'tertiary-two'],
      },
    }),
  )
})

test('should create a history entry', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await updateGenre(
    genre.id,
    {
      ...genre,
      name: 'Updated Genre',
      primaryAkas: 'primary-one, primary-two',
      secondaryAkas: 'secondary-one, secondary-two',
      tertiaryAkas: 'tertiary-one, tertiary-two',
    },
    account.id,
    dbConnection,
  )

  const {
    results: [updatedGenre],
  } = await genresDb.findAll({ filter: { ids: [genre.id] }, include: ['akas'] }, dbConnection)
  expect(updatedGenre).toEqual(
    expect.objectContaining({
      id: genre.id,
      name: 'Updated Genre',
      akas: {
        primary: ['primary-one', 'primary-two'],
        secondary: ['secondary-one', 'secondary-two'],
        tertiary: ['tertiary-one', 'tertiary-two'],
      },
    }),
  )
})

test('should throw NotFoundError if genre is not found', async ({ dbConnection }) => {
  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(updateGenre(0, GENRE_UPDATE, account.id, dbConnection)).rejects.toThrow(
    NotFoundError,
  )
})

test('should throw GenreCycleError if a 1-cycle is detected', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(
    updateGenre(genre.id, { ...GENRE_UPDATE, parents: [genre.id] }, account.id, dbConnection),
  ).rejects.toThrow(GenreCycleError)
})

test('should throw GenreCycleError if a 2-cycle is detected', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [parent, child] = await genresDb.insert(
    [getTestGenre({ id: 0, name: 'Parent' }), getTestGenre({ id: 1, name: 'Child', parents: [0] })],
    dbConnection,
  )

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(
    updateGenre(parent.id, { ...GENRE_UPDATE, parents: [child.id] }, account.id, dbConnection),
  ).rejects.toThrow(GenreCycleError)
})

test('should throw GenreCycleError if a 3-cycle is detected', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [parent, , grandchild] = await genresDb.insert(
    [
      getTestGenre({ id: 0, name: 'Parent' }),
      getTestGenre({ id: 1, name: 'Child', parents: [0] }),
      getTestGenre({ id: 2, name: 'Grandchild', parents: [1] }),
    ],
    dbConnection,
  )

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(
    updateGenre(parent.id, { ...GENRE_UPDATE, parents: [grandchild.id] }, account.id, dbConnection),
  ).rejects.toThrow(GenreCycleError)
})

test('should throw SelfInfluenceError if genre influences itself', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await expect(
    updateGenre(genre.id, { ...GENRE_UPDATE, influencedBy: [genre.id] }, account.id, dbConnection),
  ).rejects.toThrow(SelfInfluenceError)
})

test('should throw NoUpdatesError if no changes are made', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await createGenreHistoryEntry({
    genre,
    accountId: account.id,
    operation: 'CREATE',
    connection: dbConnection,
  })

  await expect(
    updateGenre(
      genre.id,
      {
        ...genre,
        primaryAkas: '',
        secondaryAkas: '',
        tertiaryAkas: '',
      },
      account.id,
      dbConnection,
    ),
  ).rejects.toThrow(NoUpdatesError)
})

test('should not create a history entry if no changes are detected', async ({ dbConnection }) => {
  const genresDb = new GenresDatabase()
  const [genre] = await genresDb.insert([getTestGenre()], dbConnection)

  const accountsDb = new AccountsDatabase()
  const [account] = await accountsDb.insert([{ username: 'Test', password: 'Test' }], dbConnection)

  await createGenreHistoryEntry({
    genre,
    accountId: account.id,
    operation: 'CREATE',
    connection: dbConnection,
  })

  try {
    await updateGenre(
      genre.id,
      {
        ...genre,
        primaryAkas: '',
        secondaryAkas: '',
        tertiaryAkas: '',
      },
      account.id,
      dbConnection,
    )
  } catch {
    // ignore
  }

  const genreHistoryDb = new GenreHistoryDatabase()
  const genreHistory = await genreHistoryDb.findByGenreId(genre.id, dbConnection)
  expect(genreHistory).toHaveLength(1)
})

---

File: ./src/lib/server/api/genres/update.ts
Contents:
import type { IDrizzleConnection } from '$lib/server/db/connection'
import { GenreService } from '$lib/server/features/genres/application/genre-service'
import { DrizzleGenreRepository } from '$lib/server/features/genres/infrastructure/genre/drizzle-genre-repository'
import { DrizzleGenreHistoryRepository } from '$lib/server/features/genres/infrastructure/genre-history/drizzle-genre-history-repository'

import type { Account, Genre } from '../../db/schema'
import { type GenreData } from './types'

export async function updateGenre(
  id: Genre['id'],
  data: GenreData,
  accountId: Account['id'],
  dbConnection: IDrizzleConnection,
): Promise<void> {
  const genreService = new GenreService(
    new DrizzleGenreRepository(dbConnection),
    new DrizzleGenreHistoryRepository(dbConnection),
  )

  await genreService.updateGenre(
    id,
    {
      ...data,
      parents: new Set(data.parents),
      influences: new Set(data.influencedBy),
      akas: {
        primary: data.primaryAkas?.length
          ? data.primaryAkas?.split(',').map((aka) => aka.trim())
          : [],
        secondary: data.secondaryAkas?.length
          ? data.secondaryAkas?.split(',').map((aka) => aka.trim())
          : [],
        tertiary: data.tertiaryAkas?.length
          ? data.tertiaryAkas?.split(',').map((aka) => aka.trim())
          : [],
      },
    },
    accountId,
  )
}

---

File: ./src/lib/server/api/releases/get-many.ts
Contents:
import { intersection, uniq } from 'ramda'

import type { IDrizzleConnection } from '$lib/server/db/connection'
import ReleaseArtistsDatabase from '$lib/server/db/controllers/release-artists'
import ReleasesDatabase, {
  type FindInclude,
  type FindManyParams,
  type FindManySortField,
  type FindManySortOrder,
  type FindRelease,
} from '$lib/server/db/controllers/releases'

export type GetManyReleasesParams<I extends FindInclude> = {
  skip?: number
  limit?: number
  include?: I[]
  filter?: {
    artists?: number[]
  }
  sort?: {
    field?: FindManySortField
    order?: FindManySortOrder
  }
}

export default async function getManyReleases<I extends FindInclude = never>(
  { skip = 0, limit, include = [], filter = {}, sort = {} }: GetManyReleasesParams<I>,
  dbConnection: IDrizzleConnection,
): Promise<{
  data: FindRelease<I>[]
  pagination: { skip: number; limit: number | undefined; total: number }
}> {
  const releasesDb = new ReleasesDatabase()

  const filter_: FindManyParams<I>['filter'] = {}

  if (filter.artists !== undefined) {
    const ids = await getArtistsFilterReleaseIds(filter.artists, dbConnection)
    filter_.ids = ids
  }

  const { results, total } = await releasesDb.findMany(
    { skip, limit, include, filter: filter_, sort },
    dbConnection,
  )

  return {
    data: results,
    pagination: { skip, limit, total },
  }
}

async function getArtistsFilterReleaseIds(artists: number[], dbConnection: IDrizzleConnection) {
  const releaseArtistsDb = new ReleaseArtistsDatabase()
  const releasesForEachArtist = await Promise.all(
    artists.map(async (artistId) => {
      const releaseArtists = await releaseArtistsDb.findByArtistId(artistId, dbConnection)
      const releases = uniq(releaseArtists.map((ra) => ra.releaseId))
      return releases
    }),
  )
  const commonReleases = releasesForEachArtist.reduce((acc, val) => intersection(acc, val))
  return commonReleases
}

---

